<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[KMP算法]]></title>
    <url>%2F2019%2F09%2F30%2FKMP%2F</url>
    <content type="text"><![CDATA[@TOC学习到串这一章，碰到一个不太好理解的算法，记录一下。 数据结构：串； 字串的定位操作通常称为串的模式匹配，算是串中最重要的操作之一。这里主要讲一下KMP模式匹配算法（即克努特-莫里斯-普拉特算法）。 1、前缀值求解在进行KMP算法操作之前需要求解将要匹配的字符串的前缀值，表现为一个前缀数组。（有些书中称为next数组）第一步，前缀表下面是即将要匹配的字符串，先写出前缀表：第二步，求出前缀值把每个前缀当成独立的字符串，找出最长的公共的前后缀，并且这个前后缀是比原始字符串要短；然后，将最后一行删除，因为最后的字符串就是其本身，同时在最前面添加一个-1。这样就构成了前缀数组：-1，0，0，1，2； 进行匹配当出现匹配失败时（如上图），查找失配位置的前缀值，比如上图匹配a和b失败，当前的前缀值是1（即图中红色的圆圈处），所以转到匹配字符串下标为1的位置（即图中绿色的圆圈处）。此时，将P串后移，使得红叉和绿圈对齐，从这里继续开始匹配。绿圈之前的字符不再需要匹配，因为前面一定是匹配的，不需要验证了。（这就是KMP算法相对于朴素匹配算法的优势）第三步，前缀实现下图是前缀值求解的算法图解：在上图中，下标为6的位置的前缀值怎么求解？ 通过观察6位置之前的字符串，发现5处的前缀值为1，要使6处的前缀值为2，只有其位置的字符为B。所以，需要做的就是检查一下，6处的字符是不是B。len——字符串达到的最大的长度；其实现为： 1234567891011121314151617181920212223// 前缀实现void prefix_table(char pattern[], int prefix[], int n) &#123; prefix[0] = 0; int len = 0; int i = 1; while (i &lt; n) &#123; if (pattern[i] == pattern[len]) &#123; len++; prefix[i] = len; i++; &#125; else &#123; if (len &gt; 0) &#123; len = prefix[len - 1]; &#125; else &#123; prefix[i] = len; i++; &#125; &#125; &#125;&#125; 12345678910// 将前缀数组后后移一位，方便后面KMP算法计算void move_prefix_table(int prefix[], int n)&#123; int i; for (i = n - 1; i &gt; 0; i--) &#123; prefix[i] = prefix[i - 1]; &#125; prefix[0] = -1;&#125; 2、KMP实现1234567891011121314151617181920212223242526272829void kmp_search(char text[], char pattern[])&#123; int n = strlen(pattern); //计算字符串长度 int * prefix = malloc(sizeof(int) * n);//内存分配 prefix_table(pattern, prefix, n);//前缀表求解 move_prefix_table(prefix, n);//前缀表移位 //text[i] ,len(text) =m; //pattern[j],len(pattrn) =n; while (i &lt; m) &#123; if (j == n - 1 &amp;&amp; text[i] == pattern[j]) &#123; printf("Found pattern at %d\n", i - j); j = prefix[j]; &#125; if (text[i] == pattern[j]) &#123; i++; j++; &#125; else &#123; j = prefix[j]; if (j == -1) &#123; i++; j++; &#125; &#125; &#125;&#125; 3、参考视频：https://www.bilibili.com/video/av11866460/?spm_id_from=333.788.videocard.0书籍：大话数据结构]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>KMP</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-线性回归]]></title>
    <url>%2F2019%2F09%2F30%2FLineRegression%2F</url>
    <content type="text"><![CDATA[​ 线性回归——一种有监督的学习算法，即在建模过程中必须同时具备自变量x和因变量y。更为概括地说，线性模型就是对输入特征加权求和，再加上一个我们称为偏置项的常数。 ​ 两种不同的训练模型的方法： 通过“闭式”方程——直接计算出最适合训练集的模型参数（也就是使训练集上的成本函数最小化的模型参数）。 使用迭代优化的方法，即梯度下降法（GD）。逐渐调整模型参数直至训练集上的成本函数调至最低。包括梯度下降的几种变体：批量梯度下降、小批量梯度下降、随机梯度下降。 ​ 一元线性回归定义​ 又称为简单线性回归模型，是指模型中只有一个自变量和一个因变量，给模型的数学表达式可以表示成： y=ax+b+\xi​ 类似于一次函数，其中$\xi$为模型的误差，$a$和$b$统称为回归系数。误差项$\xi$的存在主要是为了平衡等号两边的值，通常被称为模型无法解释的部分。如下图： 确定目标函数​ 我们希望预测值和实际值的差距尽量小，那么如何表示该差距呢？ ​ 由于误差项$\xi$是y与ax+b的差，结果可能是正值或负值，因此误差项$\xi$达到最小的问题需转换为误差平方和最小的问题（最小二乘法的思路）。 J(a,b)=\sum^{n} _{i=1} {\xi^2}=\sum^{n}_{i=1}{(y_i-ax_i-b)^2}​ 上面的函数可以称为损失函数（loss function)或效用函数（utility function）。通过分析问题，确定问题的损失函数或者效用函数；通过最优化损失函数或者效用函数，获得机器学习的模型。 ​ 求解误差项最小就是求解$J(a,b)$的最小值。该目标函数其实就是一个二元二次函数，可以使用偏导数的方法求解出a和b，进而得到目标函数的最小值。（这里可能你会有疑问：为什么求出a和b，就能得到目标函数的最小值？——这是因为这里我们已知x和y，自变量其实是a和b，J是因变量，所以要求J的最小值，自然需要对a和b求偏导。对于损失函数、代价函数、目标函数的理解参见博客：理解代价函数）推到过程如下图： Python计算得到模型的回归参数，有第三方模块statsmodels，它是专门用于统计建模的第三方模块，可以调用子模块中的ols函数计算a和b。 ​ 简单线性回归的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344import numpy as npclass SimpleLinearRegression1: def __init__(self): """初始化Simple Linear Regression 模型""" self.a_=None self.b_=None def fit(self,x_train,y_train): """根据训练数据集x_train,y_train训练Simple Linear Regression 模型""" assert x_train.ndim==1,\ "Simple Linear Regressor can only solve single feature training data" assert len(x_train)==len(y_train),\ "the size of x_train must be equal to the size of y_train" x_mean=np.mean(x_train)#计算均值 y_mean=np.mean(y_train)#计算均值 num=0.0 d=0.0 for x_i,y_i in zip(x_train,y_train): num+=(x_i-x_mean)*(y_i-y_mean)#计算a的分子 d+=(x_i-x_mean)**2#计算a的分母 self.a_=num/d#得到a self.b_=y_mean-self.a_*x_mean#得到b def predict(self,x_predict): """给定待预测数据集x_predict,返回表示x_predict的结果向量""" assert x_predict.ndim==1,\ "Simple Linear Regressor can only solve single feature training data" assert self.a_ is not None and self.b_ is not None,\ "must fit before predict!" return np.array([self._predict(x) for x in x_predict]) def _predict(self,x_signle): """给定单个待预测数据x_signle,返回x_signle的预测结果值""" return self.a_*x_signle+self.b_#根据上面计算的a和b，构建线性模型 def __repr__(self): return "SimpleLinearRegression1()" 向量化​ 从上面的简单线性回归实现中，我们可以看到，对于回归系数的计算，我们是通过for循环+数学公式计算得到的，在这里我再次贴出那段实现代码： 1234#for循环计算for x_i,y_i in zip(x_train,y_train): num+=(x_i-x_mean)*(y_i-y_mean)#计算a的分子 d+=(x_i-x_mean)**2#计算a的分母 ​ 如果数据量比较大，那么这个过程是很缓慢的，所以需要优化。 ​ 首先，从数学表达式上来看， ​ a的分子和分母都可以用下面的向量的点乘表示。向量的运算速度高于for循环。 ​ 通过numpy的向量运算可以提高性能。那么我们将上面的for循环的代码修改一下： 12num=(x_i-x_mean).dot(y_i-y_mean)d=(x_i-x_mean).dot(x_i-x_mean) #### 多元线性回归 ##### 定义 ​ 上面讨论的是一元线性回归模型，相对来说比较简单。实际上，我们的数据集的属性（即自变量）不止一个。对于含有多个属性的数据构建线性回归模型就是多元线性回归模型。如下图： ​ 从上图可以看出，X是一组向量，具有多个特征。 ​ **线性回归模型预测**： $$ \hat y^{(i)}=\theta_0+\theta_1X_1^{(1)}+\theta_2X_2^{(2)}+…\theta_nX_n^{(n)} $$ ​ **线性回归模型预测（向量化）**： $$ \hat y=X_b\cdot {\theta} $$ ​ ##### 目标函数 ​ 对于多元线性回归模型，目标函数和一元线性回归模型基本一致： ​ 上面我们添加X_0参数，使其恒等于1，这样我们就可以使用向量的方式表示预测模型了。 ​ 所以，目标函数的求解变成了： ​ 闭式解法——就是一个直接得出结果的数学方程（即多元线性回归的正规方程解）： \theta =(X_b^TX_b)^{-1}X_b^Ty​ 求解出来的$\theta$如下： 多元线性回归的实现123456789101112131415161718192021222324252627282930313233343536373839404142import numpy as np#from .metrics import r2_scoreclass LinearRegression: def __init__(self): """"初始化Linear Regression模型""" self.coef_=None self.interception_=None self._theta=None def fit_normal(self,X_train,y_train): """"根据训练数据集X_train,y_train训练Linear Regression模型""" assert X_train.shape[0]==y_train.shape[0],\ "the size of X_train must be equal to the size of y_train" X_b=np.hstack([np.ones((len(X_train),1)),X_train]) self._theta=np.linalg.inv(X_b.T.dot(X_b)).dot(X_b.T).dot(y_train) self.interception_=self._theta[0] self.coef_=self._theta[1:] return self def predict(self,X_predict): """给定待预测数据集X_predict，返回表示X——predict的结果向量""" assert self.interception_ is not None and self.coef_ is not None,\ "must fit before predict!" assert X_predict.shape[1]==len(self.coef_),\ "the feature number of X_predict must be equal to X_train" X_b = np.hstack([np.ones((len(X_predict), 1)), X_predict]) return X_b.dot(self._theta) def score(self,X_test,y_test): """根据测试数据集X_test和y_test确定当前模型的准确度""" y_predict=self.predict(X_test) #return r2_score(y_test,y_predict) def __repr__(self): return "LinearRegression()" 计算复杂度​ 标准方程求逆的矩阵$X^T\cdot X$，是一个$n*n$的矩阵（n是特征数量）。对这种矩阵求逆的计算复杂度通常为$O(n^{2.4})到O(n^{3})$之间（取决于实现）。因此当特征数量特别大时，标准方程的计算是很缓慢的。好的一面，线性模型一经训练完成，预测就非常迅速。 多项式回归定义​ 其实可以用线性模型拟合非线性数据。一个简单的方法就是将每个特征的幂次方添加为一个新特征，然后在这个拓展过的特征集上训练线性模型。这种方法被称为多项式回归。 ​ 将$X^2$和$X$分别看作两个特征，那么这个多项式回归依然可以看成线性回归。只不过对于x来说，是一个2次方程。 ​ 【注意】：当存在多个特征时，多项式回归能够发现特征和特征之间的关系（纯线性模型做不到这一点）。这是因为PolynomialFeatures会在给定的多项式阶数下，添加所有特征组合。如下： ​ 要小心特征组合的数量爆炸！！！ ##### 验证数据集与交叉验证 ​ 测试数据集不参与模型的创建。 ​ 仍然存在一个问题：**随机**？ ​ 由于我们的验证数据集都是随机的从数据集中切出来的，那么训练出来的模型可能对于这份验证数据集过拟合，但是我们只有这一份数据集，一旦这个数据集中相应的有比较极端的数据，就可能导致这个模型不准确。于是就有了**交叉验证**。 过拟合和欠拟合 ​ 我们由已知的训练数据得到的曲线，在面对新的数据的能力非常弱，即**泛化能力差**。例如，我们在训练数据集上模型的准确率很好，但是在测试数据集上模型准确率却很差。 ​ 因此，我们需要寻找泛化能力最好的地方。 ​ ​ 使用交叉验证来评估模型的泛化性能，如果模型在训练集上表现良好，但是交叉验证的泛化表现非常糟糕，那么模型就是**过拟合**。如果在二者上的表现都不佳，那就是**欠拟合**。这就是判读模型太简单还是太复杂的一种方法。如下图：分别是欠拟合和过拟合。 ​ 高阶多项式回归模型就可能过度拟合训练数据，而线性模型则是拟合不足。 学习曲线​ 另外一种方法是观察学习曲线：这个曲线绘制的是模型在训练集和验证集上，关于”训练集大小“的性能函数。要生成这个曲线，只要在不同大小的训练子集上多次训练模型即可。随着训练样本的逐渐增多，算法训练出的模型的表现能力的变化。 ​ 偏差方差权衡 模型误差=偏差+方差+不可避免的误差 ​ 偏差——原因在于错误的假设。比如假设数据是线性的，而实际上是二次的。高偏差模型最有可能对训练数据拟合不足。 ​ 方差——原因在于模型对于训练数据的微小变化过度敏感。具有高自由度的模型很可能有高方差，所以很容易对训练数据过拟合。 ​ 不可避免的误差——因为数据本身的噪声。清理数据，减少这部分误差。 正则线性模型​ 减少过拟合的一个好办法就是对模型正则化：它拥有的自由度越低，就越不容易过度拟合数据。 ​前面根据线性回归模型的参数估计公式：$\theta=(X^TX)^{-1}X^Ty$可知，得到$\theta$的前提是矩阵$X^TX$可逆。但在实际应用中，可能会出现自变量个数多于样本量（即，矩阵不是n*n的，而是n*m的）或自变量存在多重共线性（比如列方向上存在某一列是另外一列的倍数）的情况，此时无法根据公式计算回归系数的估计值$\theta$。为解决这类问题，基于线性回归模型的另外两种扩展的回归模型，分别是岭回归和LASSO回归。 岭回归​ 岭回归是线性回归的正则化版：在成本函数中添加一个等于$a\sum_{i=1}^{n}\theta_i^2$的正则项。 ​ 【注意】：正则项只能在训练的时候添加到成本函数中，一旦训练完成，你需要使用未正则化的性能指标来评估模型性能。 ​ 训练阶段使用的成本函数与测试时使用的成本函数不同是非常常见的现象。除了正则化以外，还有一个导致这种不同的原因是，训练时的成本函数通常都可以使用优化过的衍生函数，而测试用的性能指标需要尽可能接近最终目标。 也就是， $$ J(\theta)=\sum_{i=1}^n (y-X_b\theta)^2+\alpha \frac{1}{2}\sum_{i=1}^n\theta^2 $$ 为求解目标函数$J(\theta)$的最小值，需要对其求导，并令导函数为0。这里不再推导，只说一下大致步骤： 1）根据线性代数知识，展开目标函数中的平方项； 2）对展开的目标函数求导； 3）令导数为0，计算回归系数$\theta$。 求得结果： $$ \theta=(X_b^TX_b+\alpha \frac{1}{2}E)^{-1}X_b^Ty $$ 这里可以看出来，和之前没有正则项的回归系数相比，仅仅多了正则项的系数。 $\alpha$是L2正则项平方的系数，用来平衡模型的方差（回归系数的方差）和偏差（真实值和预测值之间的差异）。 对于岭回归来说，随着$\alpha$的增大，模型方差会减小而偏差会增大。 >在执行岭回归之前，必须对数据进行缩放，因为它对输入特征的大小非常敏感。 ##### LASSO回归 ​ 与岭回归一样，它也是向成本函数添加一个正则项，但是它增加的是权重向量的L1范数，而不是L2范数的平方的一半。 ​ LASSO回归的一个重要特点是它倾向于完全消除掉最不重要特征的权重（也就是将它们设置为0）。换句话说，LASSO回归会自动执行特征选择并输出一个稀疏模型（即只有很少的特征有非零权重）。 弹性网络​ 弹性网络是岭回归与LASSO回归之间的中间地带。其正则项就是岭回归和LASSO回归的正则项的混合，混合比例通过r来控制。 L1正则，L2正则 梯度下降法定义​ 前面我们求解目标函数都是通过”闭式“方程解，第二种方法是使用优化迭代的方法，即梯度下降。 ​ 梯度下降是一种通用的优化算法，其核心思想就是迭代调整参数，从而使成本函数最小化。 ​ 梯度就是分别对每个变量进行微分，然后用逗号分隔开，梯度是用&lt;&gt;包括起来的，说明梯度其实是一个向量。 J(\Theta)=0.55-(5\theta_1+2\theta_2+12\theta_3) \nabla J(\Theta)= =​ 梯度的意义： 在单变量的函数中，梯度其实就是函数的微分，代表函数在某个给定点的切线的斜率； 在多变量函数中，梯度就是一个向量，向量有方向，梯度的方向就指出了函数在给定点的上升最快的方向。 ​ 梯度下降法，是一种基于搜索的最优化方法；（不是一个机器学习算法） ​ 作用：最小化一个损失函数； ​ 梯度上升法：最大化一个效用函数。 ​ 导数可以代表方向，对应J增大的方向。 -\eta \frac{dJ}{d\theta} ​ 并不是所有函数都有唯一的极值点； ​ **解决方案**： - 多次运行，随机化初始点； - 梯度下降法的初始点也是一个超参数。 ##### 模拟实现梯度下降法 12345678910111213141516171819202122def gradient_descent(initial_theta,eta,epsilon=1e-8): theta=initial_theta theta_history.append(initial_theta) while True: gradient=dJ(theta) last_theta=theta theta=theta-eta*gradient theta_history.append(theta) if(abs(J(theta)-J(last_theta))&lt;epsilon): break def plot_theta_history(): plt.plot(plot_x,J(plot_x)) plt.plot(np.array(theta_history),J(np.array(theta_history)),'ro-') eta=0.9theta_history=[]gradient_descent(0.,eta)plot_theta_history() 线性回归中使用梯度下降法​ 应用梯度下降法，需要保证所有特征值的大小比例都差不多，否则收敛时间会长很多。 ​ 在线性回归中，我们需要求解目标函数最小，现在使用梯度下降法试试： ​ 求解梯度： ​ 实现梯度下降法： 12345678910111213141516171819202122232425262728293031323334353637383940414243def fit_gd(self,X_train,y_train,eta=0.01,n_iters=1e4): """根据训练数据集X_train,y_train,使用梯度下降法训练Linear Regression模型""" assert X_train.shape[0]==y_train.shape[0],\ "the size of X_train must be euqal to the size of y_train" def J(theta,X_b,y):#目标函数 try: return np.sum((y - X_b.dot(theta)) ** 2) / len(X_b) except: return float('inf') def dJ(theta, X_b, y):#求解偏导数 res = np.empty(len(theta)) res[0] = np.sum(X_b.dot(theta) - y) for i in range(1, len(theta)): res[i] = (X_b.dot(theta) - y).dot(X_b[:, i]) return res * 2 / len(X_b) def gradient_descent(X_b, y, initial_theta, eta, n_iters=1e4, epsilon=1e-8): theta = initial_theta i_iter = 0 while i_iter &lt; n_iters: gradient = dJ(theta, X_b, y) last_theta = theta theta = theta - eta * gradient if (abs(J(theta, X_b, y) - J(last_theta, X_b, y)) &lt; epsilon): break i_iter += 1 return theta X_b = np.hstack([np.ones((len(X_train), 1)), X_train]) initial_theta = np.zeros(X_b.shape[1]) # theta向量的行数=X_b向量的列数 self._theta=gradient_descent(X_b,y_train,initial_theta,eta,n_iters) self.interception_=self._theta[0] self.coef_=self._theta[1:] return self ​ 之前我们在目标函数中使用向量化对求解过程进行优化，这里我们也可以使用向量化。 ​ 通过向量化的方式，我们程序在求解计算时就会快很多。 随机梯度下降法​ 批量梯度下降法（Batch Gradient Descent） ​ 这是之前的向量化公式，我们在求解梯度时，每一项都要对所有的样本进行计算。每一步都使用整批训练数据。因此面对非常庞大的训练集时，算法变得极慢。但是梯度下降法随特征数量扩展的表现比较好：如果要训练的线性模型拥有几十万个特征，使用梯度下降法比标准方程快得多。 ​ 随机梯度下降法的学习率不能是一个固定值，需要是递减的。随机性的好处在于可以逃离局部最优，但缺点是永远定位不出最小值。要解决这个困境，有一个办法是逐步降低学习率。【模拟退火的思想】 ​ ​ **SGD算法实现**： 1234567891011121314151617181920212223242526272829303132333435def fit_sgd(self,X_train,y_train,n_iters=5,t0=5,t1=50): """根据训练数据集X_train,y_train,使用随机梯度下降法训练Linear Regression模型""" assert X_train.shape[0]==y_train.shape[0],\ "the size of X_train must be euqal to the size of y_train" assert n_iters&gt;=1 def dJ_sgd(theta, X_b_i, y_i): return X_b_i*(X_b_i.dot(theta)-y_i)*2. def sgd(X_b, y, initial_theta, n_iters, t0=5,t1=50): def learning_rate(t): return t0/(t+t1) theta=initial_theta m=len(X_b) for cur_iter in range(n_iters): indexes=np.random.permutation(m) X_b_new=X_b[indexes] y_new=y[indexes] for i in range(m): gradient = dJ_sgd(theta, X_b_new[i], y_new[i]) theta = theta - learning_rate(cur_iter*m+i) * gradient return theta X_b = np.hstack([np.ones((len(X_train), 1)), X_train]) initial_theta = np.zeros(X_b.shape[1]) # theta向量的行数=X_b向量的列数 self._theta=sgd(X_b,y_train,initial_theta,n_iters,t0,t1) self.interception_=self._theta[0] self.coef_=self._theta[1:] return self ##### 关于梯度的调试 衡量线性回归的指标 ​ **最好的衡量线性回归法的指标**： ​ R Squared： R^2^&lt;=1; R^2^越大越好。当我们的预测模型不犯任何错误时，R^2^得到最大值1； 当我们的模型等于基准模型时，R^2^为0； 如果R^2^&lt;0，说明我们学习到的模型还不如基准模型。此时，很有可能我们的数据不存在任何线性关系。 线性回归算法总结​ 1、评价线性回归算法：R Squared ​ 2、典型的参数学习，对比KNN：非参数学习 ​ 3、只能解决回归问题，对比KNN：既可以解决分类问题，又可以解决线性问题 ​ 4、对数据有假设：线性，对比KNN对数据没有假设 ​ 5、优点：对数据具有强解释性]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>梯度下降法</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT(v7.0+) 搭建博客：性能优化]]></title>
    <url>%2F2019%2F05%2F20%2Fhexo-performance-optimization%2F</url>
    <content type="text"><![CDATA[在访问很多博客的时候，页面加载和响应速度往往都要上十秒，严重影响用户的体验。本文将探究如何利用常用的方案来进行性能优化，主要包括: CDN加速 Nginx压缩、缓存 图床 首先，可利用 Google PageSpeed Insights 帮助分析网页加载速度，根据报告结果和优化建议进行针对性的优化。常见的网站提速方案有：cdn加速，压缩源文件，nginx gzip压缩，减少网站一些不必要的引入，图片大小等。 CDN加速在阅读下文之前，如果你还不知道 CDN 是什么，请先移步百度百科：CDN词条 进行一些了解。在所有静态资源中，对加载速度影响较大且存在大幅优化空间的主要还是「JavaScript 第三方库」脚本，设定成合适的 CDN 地址，此特性可以加速静态资源的加载。对于我 Hexo 博客来说，NexT 主题已经做好了配置，只需添加 CDN 加载源，将其改为从公共 CDN 加载即可。在 主题配置文件 _config.yml 中修改vendors： themes/next/_config.yml123456# Example:# jquery: //cdn.jsdelivr.net/npm/jquery@2/dist/jquery.min.js# jquery: //cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.jsjquery: //cdn.jsdelivr.net/npm/jquery@2.1.3/dist/jquery.min.js... 比较常用的开源项目 CDN 服务商主要有 unpkg、bootcdn、 cdnjs、jsdelivr 和 cloudflare，本站主要使用 jsdelivr 提供的 CDN 加速服务。 Nginx压缩、缓存 Nginx 是一个高性能的 Web 服务器，可以适当地分配流量（负载均衡器）、流媒体、动态调整图像大小、缓存内容等等，合理配置可以有效提高网站的响应速度。 开启gzipgzip压缩页面需要浏览器和服务器双方都支持，实际上就是服务器端压缩，传到浏览器后浏览器解压并解析。修改nginx.conf，在http模块中增加gzip配置： 1234567891011121314151617181920212223#开启gzip压缩;gzip on;#设置允许压缩的页面最小字节数;gzip_min_length 1k;#设置压缩缓冲区大小，此处设置为4个16K内存作为压缩结果流缓存gzip_buffers 4 16k;#压缩版本gzip_http_version 1.1;#设置压缩比率，最小为1，处理速度快，传输速度慢；9为最大压缩比，处理速度慢，传输速度快;级别越高，压缩就越小gzip_comp_level 6;#制定压缩的类型gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/javascript application/json image/svg+xml application/x-font-ttf font/opentype image/x-icon;#配置禁用gzip条件，支持正则。此处表示ie6及以下不启用gzip（因为ie低版本不支持）gzip_disable "MSIE [1-6]\.";#选择支持vary header；改选项可以让前端的缓存服务器缓存经过gzip压缩的页面; 这个可以不写gzip_vary on; 开启缓存修改nginx.conf，在server中配置缓存和失效时间： 12345678910111213location ~* ^.+\.(ico|gif|jpg|jpeg|png)$ &#123; access_log off; expires 30d;&#125;location ~* ^.+\.(css|js|txt|xml|swf|wav)$ &#123; access_log off; expires 24h;&#125;location ~* ^.+\.(html|htm)$ &#123; expires 1h;&#125; 图床 目前各大云服务商都提供了对象存储服务，如七牛云 QINIU、又拍云 USS、腾讯云 COS、阿里云 OSS 等。我们可以使用这些服务器来存储图片信息，并将其称为图床。 使用图床的好处： 可以减轻服务器的存储压力； 减轻应为图片带来的额外的流量消耗； 图床一般都是具有cdn加速的，可以让你的网页变得更快。 我主要是看中了cdn加速这点，这个对网站的性能提升太重要了。 常用的云存储服务费用对比： 限定符 免费存储空间 免费下载流量 免费请求 免费时间 HTTPS CDN 微博图床 无限 无限 无限 永久 七牛云 10G 10G PUT: 10万次 GET: 100万次 永久 青云QingStor 30G 11G PUT: 10万次 GET: 100万次 12个月 又拍云USS 10G 15G 无限 12个月 阿里云OSS 无 无 无 无 腾讯云COS 50G 无 无 6个月 Github 100G 无限 无限 永久 七牛云是专业云服务商，提供比较完备的服务，且免费额度足够个人博客使用。 七牛云的定位就是 CDN，让你在浏览网页的时候最快的接收到页面中的图片、音频等文件，所以非常适合个人、企业用户用来储存站点资源，且CDN加速也不会产生太多的费用。 微博图床是匿名图床，如果有一天禁止外链访问的话，图片将全部丢失。想着辛辛苦苦制作的图片有丢失的风险，马上就放弃了。【2019年4月微博图床开启了防盗链，对图片 CDN 添加了引用来源Referer检测，对于非微博站内引用的请求统统拒绝访问】 GitHub 看起来是个不错的选择，但是网络访问速度不是很理想，随即放弃了。 阿里云OSS也是个不错的选择，有个9元包年40G存储空间，无限流量。 七牛云综合比较之后：我选择了七牛云的对象存储作为图床(高效、快速、有保障)。 注册账号并实名认证注册 七牛开发者平台 账号，并前往 个人中心 -&gt; 个人信息 实名认证。 新建存储空间 进入控制台，打开 对象存储 -&gt; 新建存储空间， 即可创建新的Bucket。【存储区域】：建议选择一个离你较近的CDN【访问控制】：这里必须选择“公开空间”，因为设置为私有空间，图片的外链是无法访问的。 进入新创建的存储空间，在 空间概览里点击 自定义域名 为空间绑定融合cdn加速域名。详细的参数解释可以参考 官方域名接入文档 。【域名类型】：如果没有特殊需求，选择普通域名即可。【加速域名】：建议填写的是，您未在使用的二级或三级域名等，请勿轻易绑定www域名避免影响您的源站服务。【源站配置】：当您为存储空间绑定自定义域名的时候，源站配置默认为七牛云存储空间即可。 配置CNAME创建加速域名成功后，七牛云会提供CNAME地址，需要在域名服务提供商处将加速域名指向分配的CNAME地址，配置生效后，即可享受CDN加速服务。根据控制台的引导文档并参考 官方配置域名CNAME文档 。 上传文件进入新创建的存储空间，在 内容管理 中上传、下载、访问、修改资源，这样就可以使用资源的外链了。上传图片文件以后，复制外链连接就可以利用这个链接访问这个图片了。 上传工具如果每次都需要在web端点击上传图片，然后复制外链的操作就比较麻烦了，使用工具可以让我们更加方便地上传资源。Mac平台上有多款图床工具，找到了几个优秀的工具，做了个对比： table th:nth-of-type(2){ width: 10%;; } table th:nth-of-type(5){ width: 15%; } 名称 收费标准 优点 缺点 推荐指数 下载链接 ipic 60元/年 剪贴板、压缩、拖拽上传，功能强大，支持多种云服务 免费版只支持微博图床 Mac App Store PicGo 免费 链接上传，支持相册管理 不支持清除上传历史 PicGo.dmg PicUploader 免费 压缩上传，多文件、文件夹同时上传 不支持顶部菜单 PicUploader.zip 云存储管理 免费 链接上传，可视化相册管理 上传速度太慢，会卡死（不能忍受(°⌓°;） 云存储管理客户端 cuImage 免费 剪贴板、压缩、拖拽上传，与ipic类似 仅支持七牛云不支持链接上传 Mac App Store 如果是使用七牛云图床我推荐cuImage，它的功能完善，使用剪贴板、拖曳、甚至是快捷键都可以直接将图片上传到云存储，并直接生成Markdown外链，操作十分简便。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>七牛云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT(v7.0+) 搭建博客：功能强化]]></title>
    <url>%2F2019%2F05%2F19%2Fhexo-function-optimization%2F</url>
    <content type="text"><![CDATA[开源的力量让第三方插件的支持越来越多，本文介绍了在如何利用插件来加强网站的功能，主要包括: 分类时间线 DaoVoice 站内搜索 文章推荐 Valine评论 图片灯箱 分类时间线归档页面的时间线会让文章显示得很有条理，但是分类里却没有，可以通过修改布局自己实现这个时间线功能。 在主题的分类布局文件中添加以下代码： themes/next/layout/category.swig123456789101112131415161718192021222324252627 &#123;% for post in page.posts %&#125;+ &#123;# Show year #&#125;+ &#123;% set year %&#125;+ &#123;% set post.year = date(post.date, 'YYYY') %&#125;+ &#123;% if post.year !== year %&#125;+ &#123;% set year = post.year %&#125;+ &lt;div class="collection-title"&gt;+ &lt;h2 class="archive-year motion-element" id="archive-year-&#123;&#123; year &#125;&#125;"&gt;&#123;&#123; year &#125;&#125;&lt;/h2&gt;+ &lt;/div&gt;+ &#123;% endif %&#125;+ &#123;# endshow #&#125; &#123;&#123; post_template.render(post) &#125;&#125; &#123;% endfor %&#125; …… &#123;% block sidebar %&#125; &#123;&#123; sidebar_template.render(false) &#125;&#125;&#123;% endblock %&#125;+&#123;% block script_extra %&#125;+ &#123;% if theme.use_motion %&#125;+ &lt;script type="text/javascript" id="motion.page.archive"&gt;+ $('.archive-year').velocity('transition.slideLeftIn');+ &lt;/script&gt;+ &#123;% endif %&#125;+&#123;% endblock %&#125; 在线联系DaoVoice该功能由 DaoVoice 插件提供，效果如图： 首先去 DaoVoice官网 注册，输入邀请码 3d64b7fd，注册后查看app_id 并复制，在 主题配置文件 _config.yml 中添加daovoice的配置： themes\next\_config.yml123# Online contactdaovoice: truedaovoice_app_id: &#123;your app_id&#125; 按照官网开发文档说明里 应用设置—&gt;安装到网站的设置，在head的布局模板中插入相关 JavaScript 代码： themes/next/layout/_partials/head.swig123456789101112+&#123;% if theme.daovoice %&#125;+ &lt;script&gt;+ (function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/$&#123;your_app_id&#125;.js","daovoice")+ daovoice('init', &#123;+ app_id: "&#123;&#123;theme.daovoice_app_id&#125;&#125;"+ &#125;);+ daovoice('update');+ &lt;/script&gt;+&#123;% endif %&#125;&#123;# Export some HEXO Configurations to Front-End #&#125;&lt;script id="hexo.configurations"&gt; 具体样式设计可以在 应用设置 -&gt; 聊天设置 后边改。 站内搜索该功能由 hexo-generator-searchdb 提供，效果如图： 在根目录下执行以下命令安装相关依赖： 1$ npm install hexo-generator-searchdb --save 在 主题配置文件 _config.yml 中修改配置local_search： themes\next\_config.yml12345local_search: enable: true # 开启站内搜索 trigger: auto # 自动和手动触发 top_n_per_article: 3 # 每篇文章显示的搜索结果数量 unescape: false 搜索弹框的页边距有点点挤，在自定义样式文件中添加样式规则来增加页边距： themes\next\source\css\_custom\custom.styl12345//增加搜索弹窗的页边距.local-search-popup #local-search-result &#123; padding: 25px 40px height: calc(100% - 95px)&#125; 文章推荐该功能由 hexo-related-popular-posts 插件提供，效果如图： 在站点根目录中执行以下命令安装依赖： 1$ npm install hexo-related-popular-posts --save 在 主题配置文件 _config.yml 中开启相关文章推荐功能： themes/next/_config.yml123456related_posts: enable: true title: # custom header, leave empty to use the default one display_in_home: false params: maxCount: 3 此时会在每篇文章结尾根据标签相关性和内容相关性来推荐相关文章。 事实上并非每篇文章都需要开启该功能，可在文章 Front-Matter 中设置 related_posts 字段来控制是否在文末显示相关文章，然后修改文章布局模板中相关的判定条件： themes/next/layout/_macro/post.swig1234- &#123;% if theme.related_posts.enable and (theme.related_posts.display_in_home or not is_index) %&#125;+ &#123;% if theme.related_posts.enable and (theme.related_posts.display_in_home or not is_index) and post.related_posts %&#125; &#123;% include 'post-related.swig' with &#123; post: post &#125; %&#125; &#123;% endif %&#125; 为了方便可在草稿模板 scaffolds\draft.md 中统一添加 related_posts 字段默认值： scaffolds/draft.md1234 title: &#123;&#123; title &#125;&#125; tags: categories:+ related_posts: true Valine评论 Valine 诞生于 2017 年 8 月 7 日，是一款基于 LeanCloud 提供后端数据服务的快速、简洁且高效的无后端评论系统，支持匿名评论、持Markdown、Emoji等都是它的绝对优势，而且 Next 主题也已经内置了 Valine 组件，使用起来非常方便。 首先，在LeanCloud上注册账号并创建应用，设置LeanCloud的信息。 在 存储 -&gt; 数据 中 新建一个名为Counter 的 Class，ACL权限设置为 无限制：在 设置 -&gt; 安全中心 中添加博客域名到 Web 安全域名中，以保护LeanCloud应用的数据安全。 在LeanCloud中的Class可以理解为数据库中的数据表。Counter用于存储记录文章访问量，记录是以url作为唯一依据的，所以根据默认的permalink组成结构，如果你更改了文章的发布日期和标题中的任意一个，都会造成文章阅读数值的清零重计。 然后，在 主题配置文件 _config.yml 开启评论功能即可： themes/next/_config.yml123456789101112131415valine: enable: true # 开启 Valine 评论 # 设置应用 id 和 key appid: # your leancloud application appid appkey: # your leancloud application appkey # 关闭提醒与验证 notify: false verify: false placeholder: # 文本框默认文字 avatar: mm # gravatar style guest_info: nick,mail # 需要填写的信息字段 pageSize: 10 # 每页评论数 language: zh-cn # language, available values: en, zh-cn visitor: true # 开启文章阅读次数统计 comment_count: false # 首页是否开启评论数 有时候我们并不想在文章标题下显示评论数量，如要隐藏，可在自定义样式文件中添加如下代码： themes/next/source/css/_custom/custom.styl1234//屏蔽标题下的评论数量.post-comments-count &#123; display: none;&#125; 评论区会显示评论人的浏览器和操作系统版本号等信息，如果只想要一个干净的评论界面，而没有多余其他的信息，可在自定义样式文件中添加如下代码： themes/next/source/css/_custom/custom.styl1234//屏蔽评论组件的多余信息#comments .info, #comments .vsys &#123; display: none;&#125; 最后，集成评论服务后，所有的页面也会带有评论，包括标签、关于等页面。这里需要在添加字段comments并将值设置为 false 即可。 12345---title: 标签type: "tags"comments: false--- 图片灯箱添加灯箱功能，实现点击图片后放大聚焦图片，并支持幻灯片播放、全屏播放、缩略图、快速分享到社交媒体等，该功能由 fancyBox 提供。 在根目录下执行以下命令安装相关依赖： 1$ git clone https://github.com/theme-next/theme-next-fancybox3 themes/next/source/lib/fancybox 在 主题配置文件 _config.yml 中设置 fancybox: true： themes\next\_config.yml1fancybox: true 刷新浏览器即可生效。 结束语文章中大量的优化方案都参照了 yearito 的优化精髓，在集成第三方插件或者自定义新功能的过程中尽量做到： 可以在站点配置 / 主题配置文件中方便快捷的开启 / 关闭插件服务 可以在语言包 zh-CN.yml 中快速修改页面中的自定义文案，而不是在代码中将文字表述写死 尽量在自定义样式文件 custom.styl 和自定义布局文件 custom.swig 中添加代码，而非修改主题源码新增文件统一放在 _custom 目录下 所有以上这些原则，尽管实现起来可能更复杂，需要更多的代码，但都是为了让站点更好维护，更灵活方便。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT(v7.0+) 搭建博客：内容优化]]></title>
    <url>%2F2019%2F05%2F18%2Fhexo-content-optimization%2F</url>
    <content type="text"><![CDATA[NexT主题内提供了很多功能来让内容更加丰富，本文介绍了如何开启和定制这些功能，主要包括: 模板设置 文章发布修改时间、字数统计 文章版权声明 链接样式、底部标签样式 图片尺寸处理 代码块复制、显示和隐藏 草稿和发布 模板设置为了便于创建新文章时更加便利，可以在hexo的scaffolds文件夹内创建模板文件，比如我创建的草稿模板 scaffolds/draft.md123456---title: &#123;&#123; title &#125;&#125;categories: tags: date: &#123;&#123; date &#125;&#125;--- 文章发布修改时间在 主题配置文件 _config.yml 中修改post_meta，可用于控制信息的显示： themes/next/_config.yml1234567post_meta: item_text: true # 显示文字说明 created_at: true # 显示文章创建时间 updated_at: enable: false # 文章修改时间 another_day: false # 只有当修改时间和创建时间不是同一天的时候才显示 categories: true # 分类信息 文章字数统计该功能由 hexo-symbols-count-time 提供，效果如图： 在根目录下执行如下命令安装相关依赖： 1$ npm install hexo-symbols-count-time --save 在 站点配置文件 _config.yml 中添加symbols_count_time配置，这些配置项主要用于控制每项统计信息是否显示： _config.yml12345symbols_count_time: symbols: true # 统计单篇文章字数 time: true # 估算单篇文章阅读时间 total_symbols: false # 统计站点总字数 total_time: false # 估算站点总阅读时间 在 主题配置文件 _config.yml 中做如下修改，这些配置项主要用于控制统计信息的显示样式： themes/next/_config.yml123456symbols_count_time: separated_meta: true # 是否换行显示 统计信息 item_text_post: true # 文章统计信息中是否显示“本文字数/阅读时长”等描述文字 item_text_total: false # 站点统计信息中是否显示“本文字数/阅读时长”等描述文字 awl: 4 # Average Word Length：平均字符长度 wpm: 275 # Words Per Minute：阅读速度 文末版权声明NexT主题已经内置了版权声明功能，只需开启配置即可，效果如下： 在 主题配置文件 _config.yml 中开启文章底部的版权声明，版权声明默认使用 CC BY-NC-SA 4.0 许可协议，用户可以根据自身需要修改 licence 字段变更协议： themes/next/_config.yml12345creative_commons: license: by-nc-sa # 开启版权声明 sidebar: true # 侧边栏 post: true # post文章 language: zh-CN 默认版权声明中只有 本文作者、本文链接、版权声明 三项，如果你想添加更多内容，如 文章标题 等，需要先在语言配置文件里补全版权信息文案字段： themes/next/languages/zh-CN.yml123456copyright:+ title : 本文标题 author: 文章作者 link: 原始链接 license_title: 许可协议 license_content: "本文章采用 %s 许可协议，转载请保留原文链接及作者。" 再修改版权声明布局的相关代码： themes/next/layout/_partials/post/post-copyright.swig12345678&lt;ul class="post-copyright"&gt; &lt;li class="post-copyright-title"&gt; &lt;strong&gt;&#123;&#123; __('post.copyright.title') + __('symbol.colon') &#125;&#125;&lt;/strong&gt;&#123;# #&#125;&#123;&#123; post.title | default(config.title) &#125;&#125;&#123;# #&#125;&lt;/li&gt; &lt;li class="post-copyright-author"&gt; &lt;strong&gt;&#123;&#123; __('post.copyright.author') + __('symbol.colon') &#125;&#125; &lt;/strong&gt;&#123;# #&#125;&#123;&#123; post.author || author &#125;&#125;&#123;# 在版权样式文件中添加如下样式： themes\next\source\css\_common\components\post\post-copyright.styl1234567891011121314151617181920212223242526.swal-overlay &#123; background-color: transparent;&#125;.copy-success-message &#123; box-shadow: 0px 4px 12px rgba(0,0,0,0.15); border-radius: 4px; width: auto; margin: 16x 0px; vertical-align: top;&#125;.copy-success-message .swal-content &#123; margin: 0px 0px !important; padding: 10px 16px; line-height: 1em;&#125;.copy-success-message .message-icon &#123; color: #52c41a; margin-right: 8px;&#125;.copy-success-message .message-content &#123; font-size: 14px;&#125; 在实际使用过程中，有些文章是转载别人的文章，文末再出现个人版权声明就不太合适。此时可在Front-Matter中设定变量 copyright 用于控制是否显示版权信息。修改文章布局模板中相关代码，使得只有当主题配置文件中 post_copyright.enable 字段和 page.copyright 字段同时为 true 时才会插入版权声明： themes/next/layout/_macro/post.swig123456- &#123;% if theme.post_copyright.enable and not is_index %&#125;+ &#123;% if theme.post_copyright.enable and page.copyright and not is_index %&#125; &lt;div&gt; &#123;% include 'post-copyright.swig' with &#123; post: post &#125; %&#125; &lt;/div&gt; &#123;% endif %&#125; 为了批量为每篇新文章设定该变量并赋默认值，可以修改草稿模板内容，这样每篇草稿发布为正文后都会默认显示底部版权信息： scaffolds\draft.md1234 title: &#123;&#123; title &#125;&#125; tags: categories:+ copyright: true 链接样式主题自带的链接样式在hover时是灰色的，颜色不明显。在自定义样式文件中添加样式： themes/next/source/css/_custom/custom.styl12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849$link-color = #2780e3;$link-hover-color = #1094e8;$sidebar-link-hover-color = #0593d3; // 普通链接样式a, span.exturl &#123; &amp;:hover &#123; color: $link-hover-color; border-bottom-color: $link-hover-color; &#125; // For spanned external links. cursor: pointer;&#125;// 侧边栏链接样式.sidebar a, .sidebar span.exturl&#123; &amp;:hover &#123; color: $sidebar-link-hover-color; border-bottom-color: $sidebar-link-hover-color; &#125;&#125;// 侧边栏目录链接样式.post-toc ol a &#123; &amp;:hover &#123; color: $sidebar-link-hover-color; border-bottom-color: $sidebar-link-hover-color; &#125;&#125;//文章内链接文本样式.post-body p a&#123; color: $link-color; text-decoration: none; border-bottom: none; &amp;:hover &#123; color: $link-hover-color; text-decoration: underline; border-bottom-color: $link-hover-color; &#125;&#125;// 文章内上下一页链接样式.post-nav-prev a , .post-nav-next a&#123; &amp;:hover &#123; color: $link-hover-color; &#125;&#125; 底部标签添加图标默认情况下标签前缀是 # 字符，可以通过修改主题源码将标签的字符前缀改为图标前缀，效果如图： 在文章布局模板中找到文末标签相关代码段，将 # 换成 &lt;i class=&quot;fa fa-tags&quot;&gt;&lt;/i&gt; 即可： themes/next/layout/_macro/post.swig1234567891011 &lt;footer class="post-footer"&gt; &#123;% if post.tags and post.tags.length and not is_index %&#125; &lt;div class="post-tags"&gt; &#123;% for tag in post.tags %&#125;- &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;# &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;+ &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;&lt;i class="fa fa-tags"&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125; &lt;/div&gt; &#123;% endif %&#125; ... &lt;/footer&gt; NexT中使用 FontAwesome 作为图标库，用户可以在 FontAwesome 上找到心仪的图标来替换标签的字符前缀。 图片尺寸处理 本章节受 bobcn 的方案，自行重构了代码逻辑。 有时候原始图片的尺寸不太合适，想指定图片在文章中的大小，但是 Markdown 原生的图片语法在Hexo中是无效的，这一点让人很困扰（可能是Hexo的Bug，希望以后的版本能够解决这个问题）。现行的处理办法主要有两种方案，一种是使用html标签 1&lt;img width=200 src="/image/test.jpg" &gt; 另一种是 hexo官方文档 推荐的方式 1&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125; 但是习惯了 Markdown 的原生语法之后还是觉得这两种都不够简洁高效，用起来多有不便。于是尝试对 Next 主题进行了加强，变相扩展支持了 Markdown 的插图语法： 可指定像素方法是在 URL 后面添加 ?&lt;width&gt;x&lt;height&gt;，也可以只指定一个参数，图片会等比例缩放。 123![指定像素](/image/test.jpg?200x200)![仅指定width](/image/test.jpg?200x)![仅指定height](/image/test.jpg?x200) 可指定缩放比例方法是在 URL 后面添加 ?&lt;scale&gt;，等比例缩放图片大小至 %。 1![指定比例](/image/test.jpg?40) 如何实现这种效果的呢？首先在自定义脚本目录新建用于处理图片尺寸的 JavaScript 脚本 themes/next/source/js/_custom/hexo_resize_image.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function set_image_size(image, width, height) &#123; image.setAttribute("width", width + "px"); image.setAttribute("height", height + "px");&#125;function hexo_resize_image()&#123; var imgs = document.getElementsByTagName('img'); for (var i = imgs.length - 1; i &gt;= 0; i--) &#123; var img = imgs[i]; var src = img.getAttribute('src').toString(); var fields = src.match(/\?(\d*x\d*)/); if (fields &amp;&amp; fields.length &gt; 1) &#123; var values = fields[1].split("x"); if (values.length == 2) &#123; var width = values[0]; var height = values[1]; if (!(width.length &amp;&amp; height.length)) &#123; var n_width = img.naturalWidth; var n_height = img.naturalHeight; if (width.length &gt; 0) &#123; height = n_height*width/n_width; &#125; if (height.length &gt; 0) &#123; width = n_width*height/n_height; &#125; &#125; set_image_size(img, width, height); &#125; continue; &#125; fields = src.match(/\?(\d*)/); if (fields &amp;&amp; fields.length &gt; 1) &#123; var scale = parseFloat(fields[1].toString()); var width = scale/100.0*img.naturalWidth; var height = scale/100.0*img.naturalHeight; set_image_size(img, width, height); &#125; &#125;&#125;window.onload = hexo_resize_image; 然后在自定义布局文件最后添加 JavaScript 声明 themes/next/layout/css/_custom/custom.swig1&lt;script type="text/javascript" src="/js/custom/hexo_resize_image.js"&gt;&lt;/script&gt; 代码复制NexT主题已经内置了代码复制功能，只需开启配置即可，效果如下： 在 主题配置文件 _config.yml 中开启代码复制功能： themes/next/_config.yml123copy_button: enable: true # 开启代码复制功能 show_result: true # 显示复制结果 搜索的按钮有点移位，在自定义样式文件中调整样式： themes\next\source\css\_custom\custom.styl12345// 复制按钮样式top调整.highlight-wrap .copy-btn &#123; padding: 1px 6px; top: 3px;&#125; 代码块显示和隐藏—- 待完成 —- 草稿和发布一般我们使用` hexo new `来建立文章，这种建立方法会将新文章建立在 **source/_posts** 目录下，当使用 hexo generate 编译文件时，会将其 HTML 结果编译在 public 目录下，之后` hexo server `将会把 public 目录下所有文章发布。 这种建立文章方式是有缺点的！写文章的人都知道，一篇文章从创作到发布需要经过多次润色，若我们的文章还在创作润色中，尚未编辑完成，执行 hexo server 时也会随着一起发布，这样对读者是不友好的。 Hexo 另外提供 draft 机制，它的原理是新文章将建立在 source/_drafts 目录下，因此并不会将其编译到 public 目录下发布，而且提供了很友好的预览功能。 12$ hexo new draft &lt;title&gt; # 新建草稿文章$ hexo s --draft # 预览草稿文章 将草稿发布为正式文章： 1$ hexo P &lt;filename&gt; 其中 &lt;filename&gt; 为不包含 md 后缀的文章名称。它的原理只是将文章从 source/_drafts 移动到 source/_posts 而已。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT(v7.0+) 搭建博客：主题美化]]></title>
    <url>%2F2019%2F05%2F17%2Fhexo-theme-beautifed%2F</url>
    <content type="text"><![CDATA[本文介绍了在 NexT(v7.0+) 主题的基础上整体布局美化的方案，主要包括: Font：字体、动态背景canvas_ribbon Top：进度条、Follow me、菜单背景收缩 Footer：备案显示、运行时间、访客统计 Sidebar：近期文章、浏览进度、左边显示、目录展开 大家可以选择喜欢的方案美化自己的博客，当然最好可以再加入点自己的想法改造。 Font前端的美化，可以做的比较多，比如修改字体、修改背景等等。首先在 主题配置文件 _config.yml 中修改配置font： themes/next/_config.yml12font: enable: true # 开启前端设置 修改字体默认的字体是微软雅黑，有点审美疲劳了 (lll￢ω￢)，在浏览其他人网站的时候看到了一种很有科技感的字体 『Monda』，感觉还是不错的。如何应用到自己的博客呢？首先，可以从 frontyukle 下载字体文件，在服务器上安装。然后在 主题配置文件 _config.yml 中的修改全局字体配置： themes/next/_config.yml123global:- family: Lato+ family: Monda # 设置Monda字体 设置三角丝带背景 该功能由 Vue 作者 尤雨溪 首创。注意：添加动态背景会极大增加页面内存占用及 CPU 消耗。 首先，在根目录下执行以下命令安装相关依赖： 1$ git clone https://github.com/theme-next/theme-next-canvas-ribbon themes/next/source/lib/canvas_ribbon 然后，在 主题配置文件 _config.yml 中的修改配置canvas_ribbon： themes/next/_config.yml123canvas_ribbon: enable: true # 开启随机三角丝带背景 size: 90 # 设置丝带宽度 Top顶部我们保持简洁为主，设置主要包括：进度条、Fork、菜单等等。 加载进度条当网络不好的时候会出现白屏等待，此时如果能有加载进度提示将会提高用户操作体验。首先，在根目录下执行以下命令安装相关依赖： 1$ git clone https://github.com/theme-next/theme-next-pace themes/next/source/lib/pace 然后，修改 主题配置文件 _config.yml 中的配置pace 改为 true，并从上面提供的样式中选择一种填入pace_theme中就可以了。 右上角的Follow-Github如果你想大家在看博客的时候能快速链接到你的Github，不妨设置Github_banner，效果图如下： 修改 主题配置文件 _config.yml 中的配置github_banner，在permalink里配置自己的github地址： themes/next/_config.yml123github_banner: enable: true permalink: https://github.com/yourname 菜单背景收缩在 Muse主题方案中 Header 和 Footer 是没有背景色的，的颜色与内容一致不易区分，而且网站标题的字体不够明显，我做了几个修改 头部和底部颜色修改 网站标题加粗和颜色修改 菜单字体增大显示 在主题自定义样式文件中添加以下样式： themes/next/sources/_custom/custom.styl12345678910111213141516171819202122232425262728293031323334353637383940414243//窗口效果相关样式.sidebar &#123; box-shadow: none;&#125;// 为Header和Footer添加背景色#header, #footer &#123; background-color: rgb(245, 245, 245);&#125;//防止sidebar和footer同时开启动效时堆叠异常#sidebar, header &#123; z-index: 1 !important;&#125;//防止挡住页末文章的阅读全文按钮.main &#123; padding-bottom: 30px;&#125;// 加宽菜单间距，放大菜单图标#menu .menu-item &#123; margin: 0px 14px; .fa &#123; font-size: 16px; &#125;&#125;// Muse主题下自定义样式if hexo-config('scheme') == "Muse" &#123; .site-meta &#123; .brand &#123; color: rgb(34, 34, 34); background: none; &#125; .site-title &#123; font-size: 24px; font-weight: bold; &#125; &#125;&#125; 改完才发现顶部菜单的空间太大了，于是调节菜单高度，在自定义布局文件中添加以下代码： themes/next/layout/_custom/custom.swig1234567&#123;# 页面加载时header高度收缩动效 #&#125;&lt;script&gt; $(document).ready(function () &#123; $(".header-inner").animate(&#123;padding: "25px 0 25px"&#125;, 1000); &#125;);&lt;/script&gt; 如果 custom.swig 文件不存在，需要手动新建并在布局页面中 body 末尾引入： themes/next/layout/_layout.swig1234567 ... &#123;% include '_third-party/copy-code.swig' %&#125; &#123;% include '_third-party/chatra.swig' %&#125; &#123;% include '_third-party/tidio.swig' %&#125;+ &#123;% include '_custom/custom.swig' %&#125;&lt;/body&gt; 调节移动端显示的高度 themes/next/source/css/_schemes/Muse/_menu.styl12345678mobile() &#123; position: absolute; left: 0;- top: 52px;+ top: 95px; margin: 0; ...&#125; Footer底部设置的可完性就比较多了，建站信息、备案信息、以及访客和统计信息等信息都可以个性化定制。 ICP备案和公安备案我们的网站已经有备案号了，但是应该如何添加备案号到博客最下面呢？首先，在 主题配置文件 _config.yml 中的配置添加备案配置： themes/next/_config.yml12345678910 # 这里打开备案信息，填写ICP备案号 beian: enable: true icp: 鄂ICP证18014719号 # 这里是新加的内容，填写公安备案信息+ gongan:+ enable: true+ local: 鄂+ num: 42011102003178 然后，在语言配置文件里，添加表述文案beian： themes/next/languages/zh-CN.yml123footer:+ beian: + gongan: 公网安备%s号 接下来，删除原有的布局文件中备案样式的代码： themes/next/layout/_partials/footer.swig1234567891011 #&#125;&#123;% set current = date(Date.now(), "YYYY") %&#125;&#123;#- #&#125;&#123;% if theme.footer.beian.enable %&#125;&#123;#- #&#125; &#123;&#123; next_url('http://www.beian.miit.gov.cn', theme.footer.beian.icp + ' ') &#125;&#125;&#123;#- #&#125;&#123;% endif %&#125;&#123;# #&#125;&amp;copy; &#123;% if theme.footer.since and theme.footer.since != current %&#125;&#123;&#123; theme.footer.since &#125;&#125; – &#123;% endif %&#125;&#123;# ... &lt;span class="author" itemprop="copyrightHolder"&gt;&#123;&#123; theme.footer.copyright || author &#125;&#125;&lt;/span&gt;+ &lt;span class="post-meta-divider footer-ages-icon"&gt; | &lt;/span&gt; &#123;% if config.symbols_count_time.total_symbols %&#125; 最后，在主题布局文件中添加我们自定义的备案样式： themes/next/layout/_layout.swig1234567891011121314151617 &lt;div class="footer-inner"&gt; &#123;&#123; partial('_partials/footer.swig', &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125; &#123;% include '_third-party/analytics/analytics-with-widget.swig' %&#125;+ &lt;div class="footer-custom"&gt;+ &#123;% if theme.footer.beian.enable %&#125;&#123;#+ #&#125;&#123;&#123; next_url('http://www.beian.miit.gov.cn', theme.footer.beian.icp + ' ') &#125;&#125;&#123;#+ #&#125;&#123;% endif %&#125;+ &#123;% if theme.footer.beian.enable and theme.footer.gongan.enable %&#125;+ &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;+ &#123;% endif %&#125;+ &#123;% if theme.footer.gongan.enable %&#125;&#123;#+ #&#125; &lt;span style="padding-left:25px;background:url(/images/beian.png) no-repeat left center" rel="nofollow"&gt;&#123;#+ #&#125; &#123;&#123; theme.footer.gongan.local&#125;&#125;&#123;&#123;__('footer.beian.gongan', next_url('http://www.beian.gov.cn/portal/registerSystemInfo?recordcode='+theme.footer.gongan.num, theme.footer.gongan.num )) &#125;&#125;&#123;#+ #&#125;&#123;% endif %&#125;+ &lt;/div&gt; &#123;% block footer %&#125;&#123;% endblock %&#125; &lt;/div&gt; 网站的建站时间NexT主题已经内置了添加建站时间。在 主题配置文件 _config.yml 中修改配置since ： themes/next/_config.yml12345678910footer: # Specify the date when the site was setup. If not defined, current year will be used. since: 2018 # 修改建站时间 # Icon between year and copyright info. icon: # `heart` is recommended with animation in red (#ff0000). name: heart # 改成心型图标 # Change the color of icon, using Hex Code. color: "#ff0000" # 改成红色图标 网站的运行时间 本章节受 Yearito’s Blog | 站点运行时间统计 的启发，自行重构了代码逻辑。 接下来我们显示网站的运行时间，在这里我做了一些个性化文案，可供大家参考： 在 主题配置文件 _config.yml 中的添加 ages配置： themes/next/_config.yml1234ages: # site running time enable: true birthday: 20190419 # 网站运行时间 color: "#1094e8" 在语言配置文件里，添加表述文案age： themes/next/languages/zh-CN.yml12footer:+ age: 我已在此等候你 在主题自定义布局文件中添加以下代码： themes/next/layout/_custom/custom.swig12345678910111213141516171819202122232425&#123;# 页脚站点运行时间统计 #&#125; &#123;% if theme.footer.ages.enable %&#125; &lt;script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/moment.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.jsdelivr.net/npm/moment-precise-range-plugin@1.3.0/moment-precise-range.min.js"&gt;&lt;/script&gt; &lt;script&gt; function timer() &#123; var ages = moment.preciseDiff(moment(),moment(&#123;&#123; theme.footer.ages.birthday &#125;&#125;,"YYYYMMDD")); //去除时分秒信息 ages = ages.replace(/\s?\d&#123;0,2&#125;\s+hours?/, ""); ages = ages.replace(/\s?\d&#123;0,2&#125;\s+minutes?/, ""); ages = ages.replace(/\s?\d&#123;0,2&#125;\s+seconds?/, ""); //将年月日转换为中文 ages = ages.replace(/years?/, "年"); ages = ages.replace(/months?/, "月"); ages = ages.replace(/days?/, "天"); ages = ages.replace(/\d+/g, '&lt;span style="color:&#123;&#123; theme.footer.ages.color &#125;&#125;"&gt;$&amp;&lt;/span&gt;'); span.innerHTML = `&#123;&#123; __('footer.age')&#125;&#125; $&#123;ages&#125;`; &#125; var span = document.createElement("span"); //插入到agesicon之后 var agesicon = document.querySelector(".footer-ages-icon"); document.querySelector(".copyright").insertBefore(span, agesicon.nextSibling); timer(); &lt;/script&gt; &#123;% endif %&#125; 添加访客统计该功能由 不蒜子 提供。UV：独立访客数，PV：网站浏览量，访客数和浏览量的区别在于一个用户连续点击n篇文章，会记录n次浏览量，但只记录一次访客数，效果如图： 由于不蒜子是基于域名来进行统计计算的，所以通过 localhost:4000 端口访问的时候统计数据UV和PV都会异常的大，属于正常现象。 首先，在 主题配置文件 _config.yml 中打开不蒜子功能： themes\next\_config.yml12345busuanzi_count: enable: true total_visitors: true # 访客数 total_visitors_icon: user total_views: true # 访问量 然后，在语言配置文件里，修改个性化表述文案： themes/next/languages/zh-CN.yml12345footer:- total_views: 总访问量- total_visitors: 总访客量+ total_views: "历经 %s 次回眸才与你相遇"+ total_visitors: "我的第 %s 位朋友，" 最后，修改不蒜子模板文件： themes/next/layout/_third-party/analytics/busuanzi-counter.swig123456789101112131415161718192021222324252627282930313233&lt;div class="busuanzi-count"&gt; &lt;script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;+ &#123;% if theme.busuanzi_count.enable %&#125;+ &lt;script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;+ &#123;% if theme.busuanzi_count.total_visitors %&#125;- &lt;span class="post-meta-item-icon"&gt;- &lt;i class="fa fa-&#123;&#123; theme.busuanzi_count.total_visitors_icon &#125;&#125;"&gt;&lt;/i&gt;- &lt;/span&gt;- &lt;span class="site-uv" title="&#123;&#123; __('footer.total_visitors') &#125;&#125;"&gt;- &lt;span class="busuanzi-value" id="busuanzi_value_site_uv"&gt;&lt;/span&gt;+ &lt;span class="site-uv"&gt;+ &#123;&#123; __('footer.total_visitors', '&lt;span class="busuanzi-value" id="busuanzi_value_site_uv"&gt;&lt;/span&gt;') &#125;&#125; &lt;/span&gt; &#123;% endif %&#125;- &#123;% if theme.busuanzi_count.total_visitors and theme.busuanzi_count.total_views %&#125;- &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;- &#123;% endif %&#125;- &#123;% if theme.busuanzi_count.total_views %&#125;- &lt;span class="post-meta-item-icon"&gt;- &lt;i class="fa fa-&#123;&#123; theme.busuanzi_count.total_views_icon &#125;&#125;"&gt;&lt;/i&gt;- &lt;/span&gt;- &lt;span class="site-pv" title="&#123;&#123; __('footer.total_views') &#125;&#125;"&gt;- &lt;span class="busuanzi-value" id="busuanzi_value_site_pv"&gt;&lt;/span&gt;+ &lt;span class="site-pv"&gt;+ &#123;&#123; __('footer.total_views', '&lt;span class="busuanzi-value" id="busuanzi_value_site_pv"&gt;&lt;/span&gt;') &#125;&#125; &lt;/span&gt; &#123;% endif %&#125;+ &#123;% endif %&#125;&lt;/div&gt; 在自定义样式文件中添加如下样式： themes/next/source/css/_custom/custom.styl1234//修改不蒜子数据颜色.busuanzi-value &#123; color: #1890ff;&#125; Sidebar侧边栏里的信息有很多，比如站点信息、RSS、链接信息、目录信息等等，我们要有选择性的显示。尽量保持Next主题的宗旨 — 简洁 显示近期文章当你新写了一些好文章，想尽快告诉大家要怎么办呢？放在侧边栏里那是最合适不过了～(￣▽￣～)(～￣▽￣)～ 比如这样： 首先配置开关和文案，便于随时修改。在 主题配置文件 _config.yml 中添加近期文章recent_posts的配置： themes/next/_config.yml123# 近期文章recent_posts: truerecent_posts_layout: block 在语言配置文件里，添加表述文案recent_posts： themes/next/languages/zh-CN.yml12sidebar:+ recent_posts: 近期文章 在侧边栏原有布局文件中的合适位置添加近期文章显示代码： themes/next/layout/_macro/sidebar.swig12345678910111213141516171819202122 &#123;% if theme.social %&#125; ... &#123;% endif %&#125;+ &lt;!-- 添加近期文章 --&gt;+ &#123;% if theme.recent_posts %&#125;+ &lt;div class="links-of-blogroll motion-element &#123;&#123; "links-of-blogroll-" + theme.recent_posts_layout &#125;&#125;"&gt;+ &lt;div class="links-of-blogroll-title"&gt;+ &lt;!-- modify icon to fire by szw --&gt;+ &lt;i class="fa fa-history fa-&#123;&#123; theme.recent_posts_icon | lower &#125;&#125;" aria-hidden="true"&gt;&lt;/i&gt;+ &#123;&#123; __('sidebar.recent_posts') &#125;&#125;+ &lt;/div&gt;+ &lt;ul class="links-of-blogroll-list"&gt;+ &#123;% set posts = site.posts.sort('-date') %&#125;+ &#123;% for post in posts.slice('0', '5') %&#125;+ &lt;li&gt;+ &lt;a href="&#123;&#123; url_for(post.path) &#125;&#125;" title="&#123;&#123; post.title &#125;&#125;" target="_blank"&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt;+ &lt;/li&gt;+ &#123;% endfor %&#125;+ &lt;/ul&gt;+ &lt;/div&gt;+ &#123;% endif %&#125; 显示当前浏览进度在 主题配置文件 _config.yml 中修改back2top的scrollpercent： themes\next\_config.yml1234back2top: enable: true sidebar: false scrollpercent: true # 浏览页面的时候显示当前浏览进度 配置完之后，发现这个按钮颜色有点单调，让它炫酷点的吧 &lt;(￣ˇ￣)/ ，每次刷新可以生成不同的颜色，在自定义样式文件中添加如下样式： themes/next/source/css/_custom/custom.styl1234// 回到顶部样式.back-to-top .fa-arrow-up:before&#123; color: rgb(random-color(0, 255) - 50%, random-color(0, 255) - 50%, random-color(0, 255) - 50%);&#125; 侧边栏移到左边用惯了Ofice的人习惯导航菜单在左边的格式，如何把侧边栏放在左侧呢？NexT 主题中 Pisces 和 Gemini 支持通过主题配置文件来将侧边栏置于左侧或右侧。在 主题配置文件 _config.yml 中修改配置sidebar ： themes/next/_config.yml123sidebar:# Sidebar Position, available values: left | right (only for Pisces | Gemini). position: left # 调整侧边栏显示位置，仅支持 Pisces 和 Gemini 主题 而 Muse 和 Mist 则需要深度修改源码才能实现改变侧边栏位置： themes/next/source/css/_custom/custom.styl1234567.sidebar-toggle &#123; left: 30px;&#125;.sidebar &#123; left: 0px;&#125; 修改动效脚本代码： themes/next/source/js/src/motion.js123456789101112131415161718$(document) .on('sidebar.isShowing', function() &#123; NexT.utils.isDesktop() &amp;&amp; $('body').velocity('stop').velocity(- &#123;paddingRight: SIDEBAR_WIDTH&#125;,+ &#123;paddingLeft: SIDEBAR_WIDTH&#125;, SIDEBAR_DISPLAY_DURATION ); &#125;) ... hideSidebar: function() &#123;- NexT.utils.isDesktop() &amp;&amp; $('body').velocity('stop').velocity(&#123;paddingRight: 0&#125;);+ NexT.utils.isDesktop() &amp;&amp; $('body').velocity('stop').velocity(&#123;paddingLeft: 0&#125;); this.sidebarEl.find('.motion-element').velocity('stop').css('display', 'none'); this.sidebarEl.velocity('stop').velocity(&#123;width: 0&#125;, &#123;display: 'none'&#125;); sidebarToggleLines.init(); ...&#125; 如此以来就可以将侧边栏放置在左边了，但当窗口宽度缩小到991px之后会出现样式错误：侧边栏收缩消失但是页面左侧仍留有空白间距，此时修改如下代码即可： themes/next/source/css/_common/scaffolding/base.styl1234567891011121314body &#123; position: relative; // Required by scrollspy font-family: $font-family-base; font-size: $font-size-base; line-height: $line-height-base; color: $text-color; background: $body-bg-color;- +mobile() &#123; padding-left: 0 !important; &#125;- +tablet() &#123; padding-left: 0 !important; &#125; + +mobile() &#123; padding-right: 0 !important; &#125;+ +tablet() &#123; padding-right: 0 !important; &#125; +desktop-large() &#123; font-size: $font-size-large; &#125;&#125; 侧边栏目录展开侧边栏的TOC目录每次滑到哪儿，目录展开到哪。这样查看文章结构就很不方便，如何设置才能让文章目录默认全部都展开？在 主题配置文件 _config.yml 中修改配置toc ： themes/next/_config.yml123toc: wrap: false ## 如果标题超长，是否换行 expand_all: true ## 侧边栏是否完全展开]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT(v7.0+) 搭建博客：基础安装]]></title>
    <url>%2F2019%2F04%2F29%2Fhexo-satrted%2F</url>
    <content type="text"><![CDATA[关于如何搭建Hexo博客的文章已经有很多人写过了，并且有很多人已经写的很深刻很到位了，为什么还要重复写一遍呢？直到我看到了这位同学的博客 yearito （ ps：本站的建站优化大都参考自这里） ，我有了说服自己的理由： 你可以参考别人的技术方案，集众所长，亲自实践，然后融入自己的思考写出一篇新文章 即使并没有做出创新性的贡献，自己重新归纳一遍也有助于梳理流程，深化理解 现在百度 Google 很方便，动动手指就可以搜索到想要的答案，但是太多人都是『顺手拈来、过目就忘』，下次遇到同样的问题再搜索一遍。为什么会这样呢？不善于总结，不情愿动手思考，时而久之就会变成所谓的 “代码搬运工” ！ 闲话不多说了，我们开始吧！ 安装node.js在 官方下载网站 下载源代码，选择最后一项 Source Code解压到某一目录, 然后进入此目录,依次执行以下 3 条命令 123$ ./configure$ make$ sudo make install 安装完后查看node.js版本，检验是否安装成功 1$ node -v 安装hexo在命令行中通过 npm 来安装 hexo： 1$ npm install -g hexo-cli 本地启动hexo创建一个博客目录（例如 /my-blog），在此目录下，执行初始化命令 123$ mkdir -p my-blog$ cd my-blog$ hexo init 执行完毕后，将会生成以下文件结构： 123456789101112.|-- node_modules //依赖安装目录|-- scaffolds //模板文件夹，新建的文章将会从此目录下的文件中继承格式|-- source //资源文件夹，用于放置图片、数据、文章等资源| |-- _posts //文章目录|-- themes //主题文件夹| |-- landscape //默认主题|-- .gitignore //指定不纳入git版本控制的文件|-- _config.yml //站点配置文件|-- db.json|-- package.json`-- package-lock.json 在根目录下执行如下命令启动hexo内置的web容器 12$ hexo generate # 生成静态文件$ hexo server # 在本地服务器运行 在浏览器输入IP地址 http://localhost:4000 就可以看到我们熟悉的 Hello Word 了。 常用命令简化和组合1234$ hexo g # 等同于hexo generate$ hexo s # 等同于hexo server$ hexo p # 等同于hexo port $ hexo d # 等同于hexo deploy 当本地不想使用默认的4000端口时（比如在服务器上，默认使用80端口），可以使用 port 命令更改启动端口另外，hexo支持命令合并，比方说 生成静态文件 → 本地启动80端口，我们可以执行 1$ hexo s -g -p 80 安装NexT主题hexo 安装主题的方式非常简单, 只需几个简单的命令即可。将NexT主题文件拷贝至themes目录下，然后修改 站点配置文件 _config.yml 中的 theme字段为next即可。 cd 到博客的根目录下执行以下命令下载主题文件： 12345$ cd my-blog$ git clone https://github.com/theme-next/hexo-theme-next.git themes/next$ vim _config.ymltheme: next 清除 hexo缓存，重启服务 12$ hexo clean$ hexo s -g 大部分的设定都能在 NexT官方文档 里找到, 如主题设定、侧栏、头像、友情链接、打赏等等，在此就不多讲了，照着文档走就行了。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>

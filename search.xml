<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring Boot - 根据配置动态注入Bean]]></title>
    <url>%2F2019%2F06%2F17%2Fspring-boot-autowired-by-condition%2F</url>
    <content type="text"><![CDATA[在我们的实际业务开发过程中，往往会有这样的场景： 一套接口中有多种不同的实现，但在不同的场景下需使用指定的实现方式（比如微信小程序里仅仅支持微信支付） 在集群环境里，存在一个定时任务，定时任务不可重复执行，因此需限制只在一个节点中执行，其他节点不执行 常规思路中要实现以上的场景需求还是比较麻烦的，可能需要硬编码做 if 或者 swith 的判断，亦或是使用控制路由在调用的代码里做选择初始化。这些方式都不够优雅，也增强了组件间的耦合性！！！现在SpringBoot里有了 @Conditional注解 和 @ConditionalOnProperty注解，将变得简单许多。 ConditionalOnProperty注解介绍Spring4.X中新加入了注解@Conditional，可以实现不同条件创建不同的Bean。SpringBoot框架中封装了注解@ConditionalOnProperty，它将配置信息转换成控制某个configuration是否生效的条件。 ConditionalOnProperty源码解析springboot-autoconfigure.jar1234567891011121314151617181920212223242526272829303132333435package org.springframework.boot.autoconfigure.condition;@Retention(RetentionPolicy.RUNTIME)@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)@Documented@Conditional(OnPropertyCondition.class)public @interface ConditionalOnProperty &#123; /** * String数组 ，对应property名称的值，与name()不可同时使用， * 当 value() 所对应配置文件中的值为false时加载配置，不为fasle不加载配置 * value() 有多个值时，只要有一个值对应为false,则不加载配置 */ String[] value() default &#123;&#125;; /** * 配置中 property 的前缀，可有可无；可与 value 或 name 组合使用 */ String prefix() default ""; /** * String数组 ，property完整名称或部分名称，与 value()作用一致但不可同时使用 */ String[] name() default &#123;&#125;; /** * 比较获取到的属性值与 havingValue() 给定的值是否相同，相同才加载配置；需与 value 或 name 组合使用需 */ String havingValue() default ""; /** * 配置中缺少对应 property 时是否可以加载；为true时缺少对应配置也可加载 */ boolean matchIfMissing() default false;&#125; 由此可见：它主要通过几个属性值来实现： prefix：属性-配置前缀，可不填； name：配置文件application.yml中定义的属性名； havingValue：生效时的预期值，一般设置为true。 根据 name 在 application.yml 中获取属性的值，该值与havingValue的值比较，与其相等则当前configuration生效加载此Bean，否则则不生效。当name的值在application.yml 中不存在则返回false。 code示例12345678910111213141516171819202122232425262728293031323334353637public interface IPayService &#123; void pay();&#125;@ConditionalOnProperty(prefix = "pay", name = "type", havingValue = "alipay")@Service("payService")public class AliPayServiceImlp implements IPayService &#123; @Override public void pay() &#123; log.info("=====&gt;&gt;&gt;&gt;&gt;使用支付宝支付"); &#125;&#125;@ConditionalOnProperty(prefix = "pay", name = "type", havingValue = "weixin")@Service("payService")public class WinxinPayServiceImpl implements IPayService &#123; @Override public void pay() &#123; log.info("=====&gt;&gt;&gt;&gt;&gt;使用微信支付"); &#125;&#125;@RequestMapping(path = "test")@RestControllerpublic class TempRestController &#123; @Autowired IPayService payService; @PostMapping(path = "pay") public void pay() &#123; payService.pay(); &#125;&#125; 在指定的节点配置 pay.type=alipay 或者 weixin application.properties123pay.type = alipay----------pay.type = weixin code示例212345678@ConditionalOnProperty(prefix = "scheduling", name = "enabled", havingValue = "true")@Componentpublic class WorkTimer &#123; @Scheduled(cron = "0/5 * * * * *") public void scheduled() &#123; // ... &#125;&#125; 在指定的节点加上配置 scheduling.enabled=true，其余节点加上配置scheduling.enabled=false application.properties123scheduling.enabled = false （或为空，此时定时任务不生效）----------scheduling.enabled = true （此时定时任务生效） 知识拓展ConditionalOnProperty注解只能解决简单配置的动态注入，下面还有几种常用的条件注解使用方式，有兴趣的同学可以继续深入学习： @ConditionalOnBean：基于Bean的条件注解，根据Bean是否存在来判断是否满足条件。（可用于Bean之间相互依赖的场景） 12345678910@Component@ConditionalOnBean(name="redisTemplate")public class RedisOperBean &#123; private final RedisTemplate redisTemplate; public RedisOperBean(RedisTemplate redisTemplate) &#123; // ... &#125;&#125;// tips：不会因为找不到 RestTemplate 的bean，导致无法实例化 RedisOperBean，从而抛出异常 @ConditionalOnMissingBean：和前面一个作用正好相反的，判断Bean是否不存在 @ConditionalOnClass：从使用来看，和 ConditionalOnBean类似，基于class是否存在来做条件判断 @ConditionalOnExpression ：基于SPEL表达式的条件注解，执行Spel表达式，根据返回的true/false来判断是否满足条件]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
        <tag>Conditional</tag>
        <tag>ConditionalOnProperty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot - 配置文件外置]]></title>
    <url>%2F2019%2F06%2F12%2Fspring-boot-configure-external%2F</url>
    <content type="text"><![CDATA[Spring Boot启动会加载大量的自动配置类，相比以前 XML 的配置方式，很多显式方式申明是不需要的，从而可以更快速的开发。 Spring Boot的配置文件有两种：*.properties *文件和 *.yml *文件。使用固定的 application.properties 或者 application.yml 文件做为全局的配置文件，启动时会扫描它们作为默认配置文件。 在很多场景下，我们需要去修改配置文件，如：端口、数据库地址等等。把所有配置全都打在包里，显然不是最好的做法，更常见的做法是把配置文件放在外面，可以在需要时不动代码的前提下修改配置。 本文章将介绍如何自定义Sping Boot配置文件的位置。 配置文件默认加载位置Spring Boot提供了将配置文件放置到包外面的方法，在没有特殊配置和命令的情况下，启动时会扫描以下位置的默认配置文件以获取配置： 1234- file:./config/ # 当前目录下的/config目录- file:./ # 当前目录- classpath:/config/ # classpath里的/config目录- classpath:/ # classpath的跟目录 配置文件加载优先级参考官方文档-SpringBootConfig优先级由高到低，高优先级的配置会覆盖低优先级的配置，互补配置。 命令行指定 我们可以使用 –spring.config.location=xxx 这样的命令形式来配置指定目录下的配置文件 1234567java -jar demo.jar --spring.config.location=file:/config.yml# 或者java -jar -Dspring.config.location=file:/config.yml demo.jar# 如果是指定目录的话，则路径后必须加 /java -jar demo.jar --spring.config.location=file:/config/ 如果不希望命令行指定配置文件的话，可以在*SpringApplication *中将其禁用 SpringApplication.setAddCommandLineProperties(false) JNDI属性 java:comp/env 操作系统环境变量 tomcat启动war包应用时 ，在 tomcat/bin 的 catalina.sh文件中增加一行代码: tomcat/bin/catalina.sh1export CATALINA_OPTS="$CATALINA_OPTS -Dspring.config.location=/config.yml" jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 jar包外部的application.properties或application.yml(不带spring.profile)配置文件 jar包内部的application.properties或application.yml(不带spring.profile)配置文件 @Configuration注解类上的 @PropertySource 123456789@SpringBootApplication@PropertySource(value=&#123;"file:config.properties"&#125;, ignoreResourceNotFound = true)public class SpringbootrestdemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootrestdemoApplication.class, args); &#125;&#125;// 注意：@PropertySource注解配置路径的方式不适用于 .yml 文件]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
        <tag>property</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT(v7.0+) 搭建博客：性能优化]]></title>
    <url>%2F2019%2F05%2F20%2Fhexo-performance-optimization%2F</url>
    <content type="text"><![CDATA[在访问很多博客的时候，页面加载和响应速度往往都要上十秒，严重影响用户的体验。本文将探究如何利用常用的方案来进行性能优化，主要包括: CDN加速 Nginx压缩、缓存 图床 首先，可利用 Google PageSpeed Insights 帮助分析网页加载速度，根据报告结果和优化建议进行针对性的优化。常见的网站提速方案有：cdn加速，压缩源文件，nginx gzip压缩，减少网站一些不必要的引入，图片大小等。 CDN加速在阅读下文之前，如果你还不知道 CDN 是什么，请先移步百度百科：CDN词条 进行一些了解。在所有静态资源中，对加载速度影响较大且存在大幅优化空间的主要还是「JavaScript 第三方库」脚本，设定成合适的 CDN 地址，此特性可以加速静态资源的加载。对于我 Hexo 博客来说，NexT 主题已经做好了配置，只需添加 CDN 加载源，将其改为从公共 CDN 加载即可。在 主题配置文件 _config.yml 中修改vendors： themes/next/_config.yml123456# Example:# jquery: //cdn.jsdelivr.net/npm/jquery@2/dist/jquery.min.js# jquery: //cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.jsjquery: //cdn.jsdelivr.net/npm/jquery@2.1.3/dist/jquery.min.js... 比较常用的开源项目 CDN 服务商主要有 unpkg、bootcdn、 cdnjs、jsdelivr 和 cloudflare，本站主要使用 jsdelivr 提供的 CDN 加速服务。 Nginx压缩、缓存 Nginx 是一个高性能的 Web 服务器，可以适当地分配流量（负载均衡器）、流媒体、动态调整图像大小、缓存内容等等，合理配置可以有效提高网站的响应速度。 开启gzipgzip压缩页面需要浏览器和服务器双方都支持，实际上就是服务器端压缩，传到浏览器后浏览器解压并解析。修改nginx.conf，在http模块中增加gzip配置： 1234567891011121314151617181920212223#开启gzip压缩;gzip on;#设置允许压缩的页面最小字节数;gzip_min_length 1k;#设置压缩缓冲区大小，此处设置为4个16K内存作为压缩结果流缓存gzip_buffers 4 16k;#压缩版本gzip_http_version 1.1;#设置压缩比率，最小为1，处理速度快，传输速度慢；9为最大压缩比，处理速度慢，传输速度快;级别越高，压缩就越小gzip_comp_level 6;#制定压缩的类型gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/javascript application/json image/svg+xml application/x-font-ttf font/opentype image/x-icon;#配置禁用gzip条件，支持正则。此处表示ie6及以下不启用gzip（因为ie低版本不支持）gzip_disable "MSIE [1-6]\.";#选择支持vary header；改选项可以让前端的缓存服务器缓存经过gzip压缩的页面; 这个可以不写gzip_vary on; 开启缓存修改nginx.conf，在server中配置缓存和失效时间： 12345678910111213location ~* ^.+\.(ico|gif|jpg|jpeg|png)$ &#123; access_log off; expires 30d;&#125;location ~* ^.+\.(css|js|txt|xml|swf|wav)$ &#123; access_log off; expires 24h;&#125;location ~* ^.+\.(html|htm)$ &#123; expires 1h;&#125; 图床 目前各大云服务商都提供了对象存储服务，如七牛云 QINIU、又拍云 USS、腾讯云 COS、阿里云 OSS 等。我们可以使用这些服务器来存储图片信息，并将其称为图床。 使用图床的好处： 可以减轻服务器的存储压力； 减轻应为图片带来的额外的流量消耗； 图床一般都是具有cdn加速的，可以让你的网页变得更快。 我主要是看中了cdn加速这点，这个对网站的性能提升太重要了。 常用的云存储服务费用对比： 限定符 免费存储空间 免费下载流量 免费请求 免费时间 HTTPS CDN 微博图床 无限 无限 无限 永久 七牛云 10G 10G PUT: 10万次 GET: 100万次 永久 青云QingStor 30G 11G PUT: 10万次 GET: 100万次 12个月 又拍云USS 10G 15G 无限 12个月 阿里云OSS 无 无 无 无 腾讯云COS 50G 无 无 6个月 Github 100G 无限 无限 永久 七牛云是专业云服务商，提供比较完备的服务，且免费额度足够个人博客使用。 七牛云的定位就是 CDN，让你在浏览网页的时候最快的接收到页面中的图片、音频等文件，所以非常适合个人、企业用户用来储存站点资源，且CDN加速也不会产生太多的费用。 微博图床是匿名图床，如果有一天禁止外链访问的话，图片将全部丢失。想着辛辛苦苦制作的图片有丢失的风险，马上就放弃了。【2019年4月微博图床开启了防盗链，对图片 CDN 添加了引用来源Referer检测，对于非微博站内引用的请求统统拒绝访问】 GitHub 看起来是个不错的选择，但是网络访问速度不是很理想，随即放弃了。 阿里云OSS也是个不错的选择，有个9元包年40G存储空间，无限流量。 七牛云综合比较之后：我选择了七牛云的对象存储作为图床(高效、快速、有保障)。 注册账号并实名认证注册 七牛开发者平台 账号，并前往 个人中心 -&gt; 个人信息 实名认证。 新建存储空间 进入控制台，打开 对象存储 -&gt; 新建存储空间， 即可创建新的Bucket。【存储区域】：建议选择一个离你较近的CDN【访问控制】：这里必须选择“公开空间”，因为设置为私有空间，图片的外链是无法访问的。 进入新创建的存储空间，在 空间概览里点击 自定义域名 为空间绑定融合cdn加速域名。详细的参数解释可以参考 官方域名接入文档 。【域名类型】：如果没有特殊需求，选择普通域名即可。【加速域名】：建议填写的是，您未在使用的二级或三级域名等，请勿轻易绑定www域名避免影响您的源站服务。【源站配置】：当您为存储空间绑定自定义域名的时候，源站配置默认为七牛云存储空间即可。 配置CNAME创建加速域名成功后，七牛云会提供CNAME地址，需要在域名服务提供商处将加速域名指向分配的CNAME地址，配置生效后，即可享受CDN加速服务。根据控制台的引导文档并参考 官方配置域名CNAME文档 。 上传文件进入新创建的存储空间，在 内容管理 中上传、下载、访问、修改资源，这样就可以使用资源的外链了。上传图片文件以后，复制外链连接就可以利用这个链接访问这个图片了。 上传工具如果每次都需要在web端点击上传图片，然后复制外链的操作就比较麻烦了，使用工具可以让我们更加方便地上传资源。Mac平台上有多款图床工具，找到了几个优秀的工具，做了个对比： table th:nth-of-type(2){ width: 10%;; } table th:nth-of-type(5){ width: 15%; } 名称 收费标准 优点 缺点 推荐指数 下载链接 ipic 60元/年 剪贴板、压缩、拖拽上传，功能强大，支持多种云服务 免费版只支持微博图床 Mac App Store PicGo 免费 链接上传，支持相册管理 不支持清除上传历史 PicGo.dmg PicUploader 免费 压缩上传，多文件、文件夹同时上传 不支持顶部菜单 PicUploader.zip 云存储管理 免费 链接上传，可视化相册管理 上传速度太慢，会卡死（不能忍受(°⌓°;） 云存储管理客户端 cuImage 免费 剪贴板、压缩、拖拽上传，与ipic类似 仅支持七牛云不支持链接上传 Mac App Store 如果是使用七牛云图床我推荐cuImage，它的功能完善，使用剪贴板、拖曳、甚至是快捷键都可以直接将图片上传到云存储，并直接生成Markdown外链，操作十分简便。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>七牛云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT(v7.0+) 搭建博客：功能强化]]></title>
    <url>%2F2019%2F05%2F19%2Fhexo-function-optimization%2F</url>
    <content type="text"><![CDATA[开源的力量让第三方插件的支持越来越多，本文介绍了在如何利用插件来加强网站的功能，主要包括: 分类时间线 DaoVoice 站内搜索 文章推荐 Valine评论 图片灯箱 分类时间线归档页面的时间线会让文章显示得很有条理，但是分类里却没有，可以通过修改布局自己实现这个时间线功能。 在主题的分类布局文件中添加以下代码： themes/next/layout/category.swig123456789101112131415161718192021222324252627 &#123;% for post in page.posts %&#125;+ &#123;# Show year #&#125;+ &#123;% set year %&#125;+ &#123;% set post.year = date(post.date, 'YYYY') %&#125;+ &#123;% if post.year !== year %&#125;+ &#123;% set year = post.year %&#125;+ &lt;div class="collection-title"&gt;+ &lt;h2 class="archive-year motion-element" id="archive-year-&#123;&#123; year &#125;&#125;"&gt;&#123;&#123; year &#125;&#125;&lt;/h2&gt;+ &lt;/div&gt;+ &#123;% endif %&#125;+ &#123;# endshow #&#125; &#123;&#123; post_template.render(post) &#125;&#125; &#123;% endfor %&#125; …… &#123;% block sidebar %&#125; &#123;&#123; sidebar_template.render(false) &#125;&#125;&#123;% endblock %&#125;+&#123;% block script_extra %&#125;+ &#123;% if theme.use_motion %&#125;+ &lt;script type="text/javascript" id="motion.page.archive"&gt;+ $('.archive-year').velocity('transition.slideLeftIn');+ &lt;/script&gt;+ &#123;% endif %&#125;+&#123;% endblock %&#125; 在线联系DaoVoice该功能由 DaoVoice 插件提供，效果如图： 首先去 DaoVoice官网 注册，输入邀请码 3d64b7fd，注册后查看app_id 并复制，在 主题配置文件 _config.yml 中添加daovoice的配置： themes\next\_config.yml123# Online contactdaovoice: truedaovoice_app_id: &#123;your app_id&#125; 按照官网开发文档说明里 应用设置—&gt;安装到网站的设置，在head的布局模板中插入相关 JavaScript 代码： themes/next/layout/_partials/head.swig123456789101112+&#123;% if theme.daovoice %&#125;+ &lt;script&gt;+ (function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/$&#123;your_app_id&#125;.js","daovoice")+ daovoice('init', &#123;+ app_id: "&#123;&#123;theme.daovoice_app_id&#125;&#125;"+ &#125;);+ daovoice('update');+ &lt;/script&gt;+&#123;% endif %&#125;&#123;# Export some HEXO Configurations to Front-End #&#125;&lt;script id="hexo.configurations"&gt; 具体样式设计可以在 应用设置 -&gt; 聊天设置 后边改。 站内搜索该功能由 hexo-generator-searchdb 提供，效果如图： 在根目录下执行以下命令安装相关依赖： 1$ npm install hexo-generator-searchdb --save 在 主题配置文件 _config.yml 中修改配置local_search： themes\next\_config.yml12345local_search: enable: true # 开启站内搜索 trigger: auto # 自动和手动触发 top_n_per_article: 3 # 每篇文章显示的搜索结果数量 unescape: false 搜索弹框的页边距有点点挤，在自定义样式文件中添加样式规则来增加页边距： themes\next\source\css\_custom\custom.styl12345//增加搜索弹窗的页边距.local-search-popup #local-search-result &#123; padding: 25px 40px height: calc(100% - 95px)&#125; 文章推荐该功能由 hexo-related-popular-posts 插件提供，效果如图： 在站点根目录中执行以下命令安装依赖： 1$ npm install hexo-related-popular-posts --save 在 主题配置文件 _config.yml 中开启相关文章推荐功能： themes/next/_config.yml123456related_posts: enable: true title: # custom header, leave empty to use the default one display_in_home: false params: maxCount: 3 此时会在每篇文章结尾根据标签相关性和内容相关性来推荐相关文章。 事实上并非每篇文章都需要开启该功能，可在文章 Front-Matter 中设置 related_posts 字段来控制是否在文末显示相关文章，然后修改文章布局模板中相关的判定条件： themes/next/layout/_macro/post.swig1234- &#123;% if theme.related_posts.enable and (theme.related_posts.display_in_home or not is_index) %&#125;+ &#123;% if theme.related_posts.enable and (theme.related_posts.display_in_home or not is_index) and post.related_posts %&#125; &#123;% include 'post-related.swig' with &#123; post: post &#125; %&#125; &#123;% endif %&#125; 为了方便可在草稿模板 scaffolds\draft.md 中统一添加 related_posts 字段默认值： scaffolds/draft.md1234 title: &#123;&#123; title &#125;&#125; tags: categories:+ related_posts: true Valine评论 Valine 诞生于 2017 年 8 月 7 日，是一款基于 LeanCloud 提供后端数据服务的快速、简洁且高效的无后端评论系统，支持匿名评论、持Markdown、Emoji等都是它的绝对优势，而且 Next 主题也已经内置了 Valine 组件，使用起来非常方便。 首先，在LeanCloud上注册账号并创建应用，设置LeanCloud的信息。 在 存储 -&gt; 数据 中 新建一个名为Counter 的 Class，ACL权限设置为 无限制：在 设置 -&gt; 安全中心 中添加博客域名到 Web 安全域名中，以保护LeanCloud应用的数据安全。 在LeanCloud中的Class可以理解为数据库中的数据表。Counter用于存储记录文章访问量，记录是以url作为唯一依据的，所以根据默认的permalink组成结构，如果你更改了文章的发布日期和标题中的任意一个，都会造成文章阅读数值的清零重计。 然后，在 主题配置文件 _config.yml 开启评论功能即可： themes/next/_config.yml123456789101112131415valine: enable: true # 开启 Valine 评论 # 设置应用 id 和 key appid: # your leancloud application appid appkey: # your leancloud application appkey # 关闭提醒与验证 notify: false verify: false placeholder: # 文本框默认文字 avatar: mm # gravatar style guest_info: nick,mail # 需要填写的信息字段 pageSize: 10 # 每页评论数 language: zh-cn # language, available values: en, zh-cn visitor: true # 开启文章阅读次数统计 comment_count: false # 首页是否开启评论数 有时候我们并不想在文章标题下显示评论数量，如要隐藏，可在自定义样式文件中添加如下代码： themes/next/source/css/_custom/custom.styl1234//屏蔽标题下的评论数量.post-comments-count &#123; display: none;&#125; 评论区会显示评论人的浏览器和操作系统版本号等信息，如果只想要一个干净的评论界面，而没有多余其他的信息，可在自定义样式文件中添加如下代码： themes/next/source/css/_custom/custom.styl1234//屏蔽评论组件的多余信息#comments .info, #comments .vsys &#123; display: none;&#125; 最后，集成评论服务后，所有的页面也会带有评论，包括标签、关于等页面。这里需要在添加字段comments并将值设置为 false 即可。 12345---title: 标签type: "tags"comments: false--- 图片灯箱添加灯箱功能，实现点击图片后放大聚焦图片，并支持幻灯片播放、全屏播放、缩略图、快速分享到社交媒体等，该功能由 fancyBox 提供。 在根目录下执行以下命令安装相关依赖： 1$ git clone https://github.com/theme-next/theme-next-fancybox3 themes/next/source/lib/fancybox 在 主题配置文件 _config.yml 中设置 fancybox: true： themes\next\_config.yml1fancybox: true 刷新浏览器即可生效。 结束语文章中大量的优化方案都参照了 yearito 的优化精髓，在集成第三方插件或者自定义新功能的过程中尽量做到： 可以在站点配置 / 主题配置文件中方便快捷的开启 / 关闭插件服务 可以在语言包 zh-CN.yml 中快速修改页面中的自定义文案，而不是在代码中将文字表述写死 尽量在自定义样式文件 custom.styl 和自定义布局文件 custom.swig 中添加代码，而非修改主题源码新增文件统一放在 _custom 目录下 所有以上这些原则，尽管实现起来可能更复杂，需要更多的代码，但都是为了让站点更好维护，更灵活方便。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT(v7.0+) 搭建博客：内容优化]]></title>
    <url>%2F2019%2F05%2F18%2Fhexo-content-optimization%2F</url>
    <content type="text"><![CDATA[NexT主题内提供了很多功能来让内容更加丰富，本文介绍了如何开启和定制这些功能，主要包括: 模板设置 文章发布修改时间、字数统计 文章版权声明 链接样式、底部标签样式 图片尺寸处理 代码块复制、显示和隐藏 草稿和发布 模板设置为了便于创建新文章时更加便利，可以在hexo的scaffolds文件夹内创建模板文件，比如我创建的草稿模板 scaffolds/draft.md123456---title: &#123;&#123; title &#125;&#125;categories: tags: date: &#123;&#123; date &#125;&#125;--- 文章发布修改时间在 主题配置文件 _config.yml 中修改post_meta，可用于控制信息的显示： themes/next/_config.yml1234567post_meta: item_text: true # 显示文字说明 created_at: true # 显示文章创建时间 updated_at: enable: false # 文章修改时间 another_day: false # 只有当修改时间和创建时间不是同一天的时候才显示 categories: true # 分类信息 文章字数统计该功能由 hexo-symbols-count-time 提供，效果如图： 在根目录下执行如下命令安装相关依赖： 1$ npm install hexo-symbols-count-time --save 在 站点配置文件 _config.yml 中添加symbols_count_time配置，这些配置项主要用于控制每项统计信息是否显示： _config.yml12345symbols_count_time: symbols: true # 统计单篇文章字数 time: true # 估算单篇文章阅读时间 total_symbols: false # 统计站点总字数 total_time: false # 估算站点总阅读时间 在 主题配置文件 _config.yml 中做如下修改，这些配置项主要用于控制统计信息的显示样式： themes/next/_config.yml123456symbols_count_time: separated_meta: true # 是否换行显示 统计信息 item_text_post: true # 文章统计信息中是否显示“本文字数/阅读时长”等描述文字 item_text_total: false # 站点统计信息中是否显示“本文字数/阅读时长”等描述文字 awl: 4 # Average Word Length：平均字符长度 wpm: 275 # Words Per Minute：阅读速度 文末版权声明NexT主题已经内置了版权声明功能，只需开启配置即可，效果如下： 在 主题配置文件 _config.yml 中开启文章底部的版权声明，版权声明默认使用 CC BY-NC-SA 4.0 许可协议，用户可以根据自身需要修改 licence 字段变更协议： themes/next/_config.yml12345creative_commons: license: by-nc-sa # 开启版权声明 sidebar: true # 侧边栏 post: true # post文章 language: zh-CN 默认版权声明中只有 本文作者、本文链接、版权声明 三项，如果你想添加更多内容，如 文章标题 等，需要先在语言配置文件里补全版权信息文案字段： themes/next/languages/zh-CN.yml123456copyright:+ title : 本文标题 author: 文章作者 link: 原始链接 license_title: 许可协议 license_content: "本文章采用 %s 许可协议，转载请保留原文链接及作者。" 再修改版权声明布局的相关代码： themes/next/layout/_partials/post/post-copyright.swig12345678&lt;ul class="post-copyright"&gt; &lt;li class="post-copyright-title"&gt; &lt;strong&gt;&#123;&#123; __('post.copyright.title') + __('symbol.colon') &#125;&#125;&lt;/strong&gt;&#123;# #&#125;&#123;&#123; post.title | default(config.title) &#125;&#125;&#123;# #&#125;&lt;/li&gt; &lt;li class="post-copyright-author"&gt; &lt;strong&gt;&#123;&#123; __('post.copyright.author') + __('symbol.colon') &#125;&#125; &lt;/strong&gt;&#123;# #&#125;&#123;&#123; post.author || author &#125;&#125;&#123;# 在版权样式文件中添加如下样式： themes\next\source\css\_common\components\post\post-copyright.styl1234567891011121314151617181920212223242526.swal-overlay &#123; background-color: transparent;&#125;.copy-success-message &#123; box-shadow: 0px 4px 12px rgba(0,0,0,0.15); border-radius: 4px; width: auto; margin: 16x 0px; vertical-align: top;&#125;.copy-success-message .swal-content &#123; margin: 0px 0px !important; padding: 10px 16px; line-height: 1em;&#125;.copy-success-message .message-icon &#123; color: #52c41a; margin-right: 8px;&#125;.copy-success-message .message-content &#123; font-size: 14px;&#125; 在实际使用过程中，有些文章是转载别人的文章，文末再出现个人版权声明就不太合适。此时可在Front-Matter中设定变量 copyright 用于控制是否显示版权信息。修改文章布局模板中相关代码，使得只有当主题配置文件中 post_copyright.enable 字段和 page.copyright 字段同时为 true 时才会插入版权声明： themes/next/layout/_macro/post.swig123456- &#123;% if theme.post_copyright.enable and not is_index %&#125;+ &#123;% if theme.post_copyright.enable and page.copyright and not is_index %&#125; &lt;div&gt; &#123;% include 'post-copyright.swig' with &#123; post: post &#125; %&#125; &lt;/div&gt; &#123;% endif %&#125; 为了批量为每篇新文章设定该变量并赋默认值，可以修改草稿模板内容，这样每篇草稿发布为正文后都会默认显示底部版权信息： scaffolds\draft.md1234 title: &#123;&#123; title &#125;&#125; tags: categories:+ copyright: true 链接样式主题自带的链接样式在hover时是灰色的，颜色不明显。在自定义样式文件中添加样式： themes/next/source/css/_custom/custom.styl12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849$link-color = #2780e3;$link-hover-color = #1094e8;$sidebar-link-hover-color = #0593d3; // 普通链接样式a, span.exturl &#123; &amp;:hover &#123; color: $link-hover-color; border-bottom-color: $link-hover-color; &#125; // For spanned external links. cursor: pointer;&#125;// 侧边栏链接样式.sidebar a, .sidebar span.exturl&#123; &amp;:hover &#123; color: $sidebar-link-hover-color; border-bottom-color: $sidebar-link-hover-color; &#125;&#125;// 侧边栏目录链接样式.post-toc ol a &#123; &amp;:hover &#123; color: $sidebar-link-hover-color; border-bottom-color: $sidebar-link-hover-color; &#125;&#125;//文章内链接文本样式.post-body p a&#123; color: $link-color; text-decoration: none; border-bottom: none; &amp;:hover &#123; color: $link-hover-color; text-decoration: underline; border-bottom-color: $link-hover-color; &#125;&#125;// 文章内上下一页链接样式.post-nav-prev a , .post-nav-next a&#123; &amp;:hover &#123; color: $link-hover-color; &#125;&#125; 底部标签添加图标默认情况下标签前缀是 # 字符，可以通过修改主题源码将标签的字符前缀改为图标前缀，效果如图： 在文章布局模板中找到文末标签相关代码段，将 # 换成 &lt;i class=&quot;fa fa-tags&quot;&gt;&lt;/i&gt; 即可： themes/next/layout/_macro/post.swig1234567891011 &lt;footer class="post-footer"&gt; &#123;% if post.tags and post.tags.length and not is_index %&#125; &lt;div class="post-tags"&gt; &#123;% for tag in post.tags %&#125;- &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;# &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;+ &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;&lt;i class="fa fa-tags"&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125; &lt;/div&gt; &#123;% endif %&#125; ... &lt;/footer&gt; NexT中使用 FontAwesome 作为图标库，用户可以在 FontAwesome 上找到心仪的图标来替换标签的字符前缀。 图片尺寸处理 本章节受 bobcn 的方案，自行重构了代码逻辑。 有时候原始图片的尺寸不太合适，想指定图片在文章中的大小，但是 Markdown 原生的图片语法在Hexo中是无效的，这一点让人很困扰（可能是Hexo的Bug，希望以后的版本能够解决这个问题）。现行的处理办法主要有两种方案，一种是使用html标签 1&lt;img width=200 src="/image/test.jpg" &gt; 另一种是 hexo官方文档 推荐的方式 1&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125; 但是习惯了 Markdown 的原生语法之后还是觉得这两种都不够简洁高效，用起来多有不便。于是尝试对 Next 主题进行了加强，变相扩展支持了 Markdown 的插图语法： 可指定像素方法是在 URL 后面添加 ?&lt;width&gt;x&lt;height&gt;，也可以只指定一个参数，图片会等比例缩放。 123![指定像素](/image/test.jpg?200x200)![仅指定width](/image/test.jpg?200x)![仅指定height](/image/test.jpg?x200) 可指定缩放比例方法是在 URL 后面添加 ?&lt;scale&gt;，等比例缩放图片大小至 %。 1![指定比例](/image/test.jpg?40) 如何实现这种效果的呢？首先在自定义脚本目录新建用于处理图片尺寸的 JavaScript 脚本 themes/next/source/js/_custom/hexo_resize_image.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function set_image_size(image, width, height) &#123; image.setAttribute("width", width + "px"); image.setAttribute("height", height + "px");&#125;function hexo_resize_image()&#123; var imgs = document.getElementsByTagName('img'); for (var i = imgs.length - 1; i &gt;= 0; i--) &#123; var img = imgs[i]; var src = img.getAttribute('src').toString(); var fields = src.match(/\?(\d*x\d*)/); if (fields &amp;&amp; fields.length &gt; 1) &#123; var values = fields[1].split("x"); if (values.length == 2) &#123; var width = values[0]; var height = values[1]; if (!(width.length &amp;&amp; height.length)) &#123; var n_width = img.naturalWidth; var n_height = img.naturalHeight; if (width.length &gt; 0) &#123; height = n_height*width/n_width; &#125; if (height.length &gt; 0) &#123; width = n_width*height/n_height; &#125; &#125; set_image_size(img, width, height); &#125; continue; &#125; fields = src.match(/\?(\d*)/); if (fields &amp;&amp; fields.length &gt; 1) &#123; var scale = parseFloat(fields[1].toString()); var width = scale/100.0*img.naturalWidth; var height = scale/100.0*img.naturalHeight; set_image_size(img, width, height); &#125; &#125;&#125;window.onload = hexo_resize_image; 然后在自定义布局文件最后添加 JavaScript 声明 themes/next/layout/css/_custom/custom.swig1&lt;script type="text/javascript" src="/js/custom/hexo_resize_image.js"&gt;&lt;/script&gt; 代码复制NexT主题已经内置了代码复制功能，只需开启配置即可，效果如下： 在 主题配置文件 _config.yml 中开启代码复制功能： themes/next/_config.yml123copy_button: enable: true # 开启代码复制功能 show_result: true # 显示复制结果 搜索的按钮有点移位，在自定义样式文件中调整样式： themes\next\source\css\_custom\custom.styl12345// 复制按钮样式top调整.highlight-wrap .copy-btn &#123; padding: 1px 6px; top: 3px;&#125; 代码块显示和隐藏— 待完成 — 草稿和发布一般我们使用` hexo new `来建立文章，这种建立方法会将新文章建立在 **source/_posts** 目录下，当使用 hexo generate 编译文件时，会将其 HTML 结果编译在 public 目录下，之后` hexo server `将会把 public 目录下所有文章发布。 这种建立文章方式是有缺点的！写文章的人都知道，一篇文章从创作到发布需要经过多次润色，若我们的文章还在创作润色中，尚未编辑完成，执行 hexo server 时也会随着一起发布，这样对读者是不友好的。 Hexo 另外提供 draft 机制，它的原理是新文章将建立在 source/_drafts 目录下，因此并不会将其编译到 public 目录下发布，而且提供了很友好的预览功能。 12$ hexo new draft &lt;title&gt; # 新建草稿文章$ hexo s --draft # 预览草稿文章 将草稿发布为正式文章： 1$ hexo P &lt;filename&gt; 其中 &lt;filename&gt; 为不包含 md 后缀的文章名称。它的原理只是将文章从 source/_drafts 移动到 source/_posts 而已。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT(v7.0+) 搭建博客：主题美化]]></title>
    <url>%2F2019%2F05%2F17%2Fhexo-theme-beautifed%2F</url>
    <content type="text"><![CDATA[本文介绍了在 NexT(v7.0+) 主题的基础上整体布局美化的方案，主要包括: Font：字体、动态背景canvas_ribbon Top：进度条、Follow me、菜单背景收缩 Footer：备案显示、运行时间、访客统计 Sidebar：近期文章、浏览进度、左边显示、目录展开 大家可以选择喜欢的方案美化自己的博客，当然最好可以再加入点自己的想法改造。 Font前端的美化，可以做的比较多，比如修改字体、修改背景等等。首先在 主题配置文件 _config.yml 中修改配置font： themes/next/_config.yml12font: enable: true # 开启前端设置 修改字体默认的字体是微软雅黑，有点审美疲劳了 (lll￢ω￢)，在浏览其他人网站的时候看到了一种很有科技感的字体 『Monda』，感觉还是不错的。如何应用到自己的博客呢？首先，可以从 frontyukle 下载字体文件，在服务器上安装。然后在 主题配置文件 _config.yml 中的修改全局字体配置： themes/next/_config.yml123global:- family: Lato+ family: Monda # 设置Monda字体 设置三角丝带背景 该功能由 Vue 作者 尤雨溪 首创。注意：添加动态背景会极大增加页面内存占用及 CPU 消耗。 首先，在根目录下执行以下命令安装相关依赖： 1$ git clone https://github.com/theme-next/theme-next-canvas-ribbon themes/next/source/lib/canvas_ribbon 然后，在 主题配置文件 _config.yml 中的修改配置canvas_ribbon： themes/next/_config.yml123canvas_ribbon: enable: true # 开启随机三角丝带背景 size: 90 # 设置丝带宽度 Top顶部我们保持简洁为主，设置主要包括：进度条、Fork、菜单等等。 加载进度条当网络不好的时候会出现白屏等待，此时如果能有加载进度提示将会提高用户操作体验。首先，在根目录下执行以下命令安装相关依赖： 1$ git clone https://github.com/theme-next/theme-next-pace themes/next/source/lib/pace 然后，修改 主题配置文件 _config.yml 中的配置pace 改为 true，并从上面提供的样式中选择一种填入pace_theme中就可以了。 右上角的Follow-Github如果你想大家在看博客的时候能快速链接到你的Github，不妨设置Github_banner，效果图如下： 修改 主题配置文件 _config.yml 中的配置github_banner，在permalink里配置自己的github地址： themes/next/_config.yml123github_banner: enable: true permalink: https://github.com/yourname 菜单背景收缩在 Muse主题方案中 Header 和 Footer 是没有背景色的，的颜色与内容一致不易区分，而且网站标题的字体不够明显，我做了几个修改 头部和底部颜色修改 网站标题加粗和颜色修改 菜单字体增大显示 在主题自定义样式文件中添加以下样式： themes/next/sources/_custom/custom.styl12345678910111213141516171819202122232425262728293031323334353637383940414243//窗口效果相关样式.sidebar &#123; box-shadow: none;&#125;// 为Header和Footer添加背景色#header, #footer &#123; background-color: rgb(245, 245, 245);&#125;//防止sidebar和footer同时开启动效时堆叠异常#sidebar, header &#123; z-index: 1 !important;&#125;//防止挡住页末文章的阅读全文按钮.main &#123; padding-bottom: 30px;&#125;// 加宽菜单间距，放大菜单图标#menu .menu-item &#123; margin: 0px 14px; .fa &#123; font-size: 16px; &#125;&#125;// Muse主题下自定义样式if hexo-config('scheme') == "Muse" &#123; .site-meta &#123; .brand &#123; color: rgb(34, 34, 34); background: none; &#125; .site-title &#123; font-size: 24px; font-weight: bold; &#125; &#125;&#125; 改完才发现顶部菜单的空间太大了，于是调节菜单高度，在自定义布局文件中添加以下代码： themes/next/layout/_custom/custom.swig1234567&#123;# 页面加载时header高度收缩动效 #&#125;&lt;script&gt; $(document).ready(function () &#123; $(".header-inner").animate(&#123;padding: "25px 0 25px"&#125;, 1000); &#125;);&lt;/script&gt; 如果 custom.swig 文件不存在，需要手动新建并在布局页面中 body 末尾引入： themes/next/layout/_layout.swig1234567 ... &#123;% include '_third-party/copy-code.swig' %&#125; &#123;% include '_third-party/chatra.swig' %&#125; &#123;% include '_third-party/tidio.swig' %&#125;+ &#123;% include '_custom/custom.swig' %&#125;&lt;/body&gt; 调节移动端显示的高度 themes/next/source/css/_schemes/Muse/_menu.styl12345678mobile() &#123; position: absolute; left: 0;- top: 52px;+ top: 95px; margin: 0; ...&#125; Footer底部设置的可完性就比较多了，建站信息、备案信息、以及访客和统计信息等信息都可以个性化定制。 ICP备案和公安备案我们的网站已经有备案号了，但是应该如何添加备案号到博客最下面呢？首先，在 主题配置文件 _config.yml 中的配置添加备案配置： themes/next/_config.yml12345678910 # 这里打开备案信息，填写ICP备案号 beian: enable: true icp: 鄂ICP证18014719号 # 这里是新加的内容，填写公安备案信息+ gongan:+ enable: true+ local: 鄂+ num: 42011102003178 然后，在语言配置文件里，添加表述文案beian： themes/next/languages/zh-CN.yml123footer:+ beian: + gongan: 公网安备%s号 接下来，删除原有的布局文件中备案样式的代码： themes/next/layout/_partials/footer.swig1234567891011 #&#125;&#123;% set current = date(Date.now(), "YYYY") %&#125;&#123;#- #&#125;&#123;% if theme.footer.beian.enable %&#125;&#123;#- #&#125; &#123;&#123; next_url('http://www.beian.miit.gov.cn', theme.footer.beian.icp + ' ') &#125;&#125;&#123;#- #&#125;&#123;% endif %&#125;&#123;# #&#125;&amp;copy; &#123;% if theme.footer.since and theme.footer.since != current %&#125;&#123;&#123; theme.footer.since &#125;&#125; – &#123;% endif %&#125;&#123;# ... &lt;span class="author" itemprop="copyrightHolder"&gt;&#123;&#123; theme.footer.copyright || author &#125;&#125;&lt;/span&gt;+ &lt;span class="post-meta-divider footer-ages-icon"&gt; | &lt;/span&gt; &#123;% if config.symbols_count_time.total_symbols %&#125; 最后，在主题布局文件中添加我们自定义的备案样式： themes/next/layout/_layout.swig1234567891011121314151617 &lt;div class="footer-inner"&gt; &#123;&#123; partial('_partials/footer.swig', &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125; &#123;% include '_third-party/analytics/analytics-with-widget.swig' %&#125;+ &lt;div class="footer-custom"&gt;+ &#123;% if theme.footer.beian.enable %&#125;&#123;#+ #&#125;&#123;&#123; next_url('http://www.beian.miit.gov.cn', theme.footer.beian.icp + ' ') &#125;&#125;&#123;#+ #&#125;&#123;% endif %&#125;+ &#123;% if theme.footer.beian.enable and theme.footer.gongan.enable %&#125;+ &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;+ &#123;% endif %&#125;+ &#123;% if theme.footer.gongan.enable %&#125;&#123;#+ #&#125; &lt;span style="padding-left:25px;background:url(/images/beian.png) no-repeat left center" rel="nofollow"&gt;&#123;#+ #&#125; &#123;&#123; theme.footer.gongan.local&#125;&#125;&#123;&#123;__('footer.beian.gongan', next_url('http://www.beian.gov.cn/portal/registerSystemInfo?recordcode='+theme.footer.gongan.num, theme.footer.gongan.num )) &#125;&#125;&#123;#+ #&#125;&#123;% endif %&#125;+ &lt;/div&gt; &#123;% block footer %&#125;&#123;% endblock %&#125; &lt;/div&gt; 网站的建站时间NexT主题已经内置了添加建站时间。在 主题配置文件 _config.yml 中修改配置since ： themes/next/_config.yml12345678910footer: # Specify the date when the site was setup. If not defined, current year will be used. since: 2018 # 修改建站时间 # Icon between year and copyright info. icon: # `heart` is recommended with animation in red (#ff0000). name: heart # 改成心型图标 # Change the color of icon, using Hex Code. color: "#ff0000" # 改成红色图标 网站的运行时间 本章节受 Yearito’s Blog | 站点运行时间统计 的启发，自行重构了代码逻辑。 接下来我们显示网站的运行时间，在这里我做了一些个性化文案，可供大家参考： 在 主题配置文件 _config.yml 中的添加 ages配置： themes/next/_config.yml1234ages: # site running time enable: true birthday: 20190419 # 网站运行时间 color: "#1094e8" 在语言配置文件里，添加表述文案age： themes/next/languages/zh-CN.yml12footer:+ age: 我已在此等候你 在主题自定义布局文件中添加以下代码： themes/next/layout/_custom/custom.swig12345678910111213141516171819202122232425&#123;# 页脚站点运行时间统计 #&#125; &#123;% if theme.footer.ages.enable %&#125; &lt;script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/moment.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.jsdelivr.net/npm/moment-precise-range-plugin@1.3.0/moment-precise-range.min.js"&gt;&lt;/script&gt; &lt;script&gt; function timer() &#123; var ages = moment.preciseDiff(moment(),moment(&#123;&#123; theme.footer.ages.birthday &#125;&#125;,"YYYYMMDD")); //去除时分秒信息 ages = ages.replace(/\s?\d&#123;0,2&#125;\s+hours?/, ""); ages = ages.replace(/\s?\d&#123;0,2&#125;\s+minutes?/, ""); ages = ages.replace(/\s?\d&#123;0,2&#125;\s+seconds?/, ""); //将年月日转换为中文 ages = ages.replace(/years?/, "年"); ages = ages.replace(/months?/, "月"); ages = ages.replace(/days?/, "天"); ages = ages.replace(/\d+/g, '&lt;span style="color:&#123;&#123; theme.footer.ages.color &#125;&#125;"&gt;$&amp;&lt;/span&gt;'); span.innerHTML = `&#123;&#123; __('footer.age')&#125;&#125; $&#123;ages&#125;`; &#125; var span = document.createElement("span"); //插入到agesicon之后 var agesicon = document.querySelector(".footer-ages-icon"); document.querySelector(".copyright").insertBefore(span, agesicon.nextSibling); timer(); &lt;/script&gt; &#123;% endif %&#125; 添加访客统计该功能由 不蒜子 提供。UV：独立访客数，PV：网站浏览量，访客数和浏览量的区别在于一个用户连续点击n篇文章，会记录n次浏览量，但只记录一次访客数，效果如图： 由于不蒜子是基于域名来进行统计计算的，所以通过 localhost:4000 端口访问的时候统计数据UV和PV都会异常的大，属于正常现象。 首先，在 主题配置文件 _config.yml 中打开不蒜子功能： themes\next\_config.yml12345busuanzi_count: enable: true total_visitors: true # 访客数 total_visitors_icon: user total_views: true # 访问量 然后，在语言配置文件里，修改个性化表述文案： themes/next/languages/zh-CN.yml12345footer:- total_views: 总访问量- total_visitors: 总访客量+ total_views: "历经 %s 次回眸才与你相遇"+ total_visitors: "我的第 %s 位朋友，" 最后，修改不蒜子模板文件： themes/next/layout/_third-party/analytics/busuanzi-counter.swig123456789101112131415161718192021222324252627282930313233&lt;div class="busuanzi-count"&gt; &lt;script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;+ &#123;% if theme.busuanzi_count.enable %&#125;+ &lt;script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;+ &#123;% if theme.busuanzi_count.total_visitors %&#125;- &lt;span class="post-meta-item-icon"&gt;- &lt;i class="fa fa-&#123;&#123; theme.busuanzi_count.total_visitors_icon &#125;&#125;"&gt;&lt;/i&gt;- &lt;/span&gt;- &lt;span class="site-uv" title="&#123;&#123; __('footer.total_visitors') &#125;&#125;"&gt;- &lt;span class="busuanzi-value" id="busuanzi_value_site_uv"&gt;&lt;/span&gt;+ &lt;span class="site-uv"&gt;+ &#123;&#123; __('footer.total_visitors', '&lt;span class="busuanzi-value" id="busuanzi_value_site_uv"&gt;&lt;/span&gt;') &#125;&#125; &lt;/span&gt; &#123;% endif %&#125;- &#123;% if theme.busuanzi_count.total_visitors and theme.busuanzi_count.total_views %&#125;- &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;- &#123;% endif %&#125;- &#123;% if theme.busuanzi_count.total_views %&#125;- &lt;span class="post-meta-item-icon"&gt;- &lt;i class="fa fa-&#123;&#123; theme.busuanzi_count.total_views_icon &#125;&#125;"&gt;&lt;/i&gt;- &lt;/span&gt;- &lt;span class="site-pv" title="&#123;&#123; __('footer.total_views') &#125;&#125;"&gt;- &lt;span class="busuanzi-value" id="busuanzi_value_site_pv"&gt;&lt;/span&gt;+ &lt;span class="site-pv"&gt;+ &#123;&#123; __('footer.total_views', '&lt;span class="busuanzi-value" id="busuanzi_value_site_pv"&gt;&lt;/span&gt;') &#125;&#125; &lt;/span&gt; &#123;% endif %&#125;+ &#123;% endif %&#125;&lt;/div&gt; 在自定义样式文件中添加如下样式： themes/next/source/css/_custom/custom.styl1234//修改不蒜子数据颜色.busuanzi-value &#123; color: #1890ff;&#125; Sidebar侧边栏里的信息有很多，比如站点信息、RSS、链接信息、目录信息等等，我们要有选择性的显示。尽量保持Next主题的宗旨 – 简洁 显示近期文章当你新写了一些好文章，想尽快告诉大家要怎么办呢？放在侧边栏里那是最合适不过了～(￣▽￣～)(～￣▽￣)～ 比如这样： 首先配置开关和文案，便于随时修改。在 主题配置文件 _config.yml 中添加近期文章recent_posts的配置： themes/next/_config.yml123# 近期文章recent_posts: truerecent_posts_layout: block 在语言配置文件里，添加表述文案recent_posts： themes/next/languages/zh-CN.yml12sidebar:+ recent_posts: 近期文章 在侧边栏原有布局文件中的合适位置添加近期文章显示代码： themes/next/layout/_macro/sidebar.swig12345678910111213141516171819202122 &#123;% if theme.social %&#125; ... &#123;% endif %&#125;+ &lt;!-- 添加近期文章 --&gt;+ &#123;% if theme.recent_posts %&#125;+ &lt;div class="links-of-blogroll motion-element &#123;&#123; "links-of-blogroll-" + theme.recent_posts_layout &#125;&#125;"&gt;+ &lt;div class="links-of-blogroll-title"&gt;+ &lt;!-- modify icon to fire by szw --&gt;+ &lt;i class="fa fa-history fa-&#123;&#123; theme.recent_posts_icon | lower &#125;&#125;" aria-hidden="true"&gt;&lt;/i&gt;+ &#123;&#123; __('sidebar.recent_posts') &#125;&#125;+ &lt;/div&gt;+ &lt;ul class="links-of-blogroll-list"&gt;+ &#123;% set posts = site.posts.sort('-date') %&#125;+ &#123;% for post in posts.slice('0', '5') %&#125;+ &lt;li&gt;+ &lt;a href="&#123;&#123; url_for(post.path) &#125;&#125;" title="&#123;&#123; post.title &#125;&#125;" target="_blank"&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt;+ &lt;/li&gt;+ &#123;% endfor %&#125;+ &lt;/ul&gt;+ &lt;/div&gt;+ &#123;% endif %&#125; 显示当前浏览进度在 主题配置文件 _config.yml 中修改back2top的scrollpercent： themes\next\_config.yml1234back2top: enable: true sidebar: false scrollpercent: true # 浏览页面的时候显示当前浏览进度 配置完之后，发现这个按钮颜色有点单调，让它炫酷点的吧 &lt;(￣ˇ￣)/ ，每次刷新可以生成不同的颜色，在自定义样式文件中添加如下样式： themes/next/source/css/_custom/custom.styl1234// 回到顶部样式.back-to-top .fa-arrow-up:before&#123; color: rgb(random-color(0, 255) - 50%, random-color(0, 255) - 50%, random-color(0, 255) - 50%);&#125; 侧边栏移到左边用惯了Ofice的人习惯导航菜单在左边的格式，如何把侧边栏放在左侧呢？NexT 主题中 Pisces 和 Gemini 支持通过主题配置文件来将侧边栏置于左侧或右侧。在 主题配置文件 _config.yml 中修改配置sidebar ： themes/next/_config.yml123sidebar:# Sidebar Position, available values: left | right (only for Pisces | Gemini). position: left # 调整侧边栏显示位置，仅支持 Pisces 和 Gemini 主题 而 Muse 和 Mist 则需要深度修改源码才能实现改变侧边栏位置： themes/next/source/css/_custom/custom.styl1234567.sidebar-toggle &#123; left: 30px;&#125;.sidebar &#123; left: 0px;&#125; 修改动效脚本代码： themes/next/source/js/src/motion.js123456789101112131415161718$(document) .on('sidebar.isShowing', function() &#123; NexT.utils.isDesktop() &amp;&amp; $('body').velocity('stop').velocity(- &#123;paddingRight: SIDEBAR_WIDTH&#125;,+ &#123;paddingLeft: SIDEBAR_WIDTH&#125;, SIDEBAR_DISPLAY_DURATION ); &#125;) ... hideSidebar: function() &#123;- NexT.utils.isDesktop() &amp;&amp; $('body').velocity('stop').velocity(&#123;paddingRight: 0&#125;);+ NexT.utils.isDesktop() &amp;&amp; $('body').velocity('stop').velocity(&#123;paddingLeft: 0&#125;); this.sidebarEl.find('.motion-element').velocity('stop').css('display', 'none'); this.sidebarEl.velocity('stop').velocity(&#123;width: 0&#125;, &#123;display: 'none'&#125;); sidebarToggleLines.init(); ...&#125; 如此以来就可以将侧边栏放置在左边了，但当窗口宽度缩小到991px之后会出现样式错误：侧边栏收缩消失但是页面左侧仍留有空白间距，此时修改如下代码即可： themes/next/source/css/_common/scaffolding/base.styl1234567891011121314body &#123; position: relative; // Required by scrollspy font-family: $font-family-base; font-size: $font-size-base; line-height: $line-height-base; color: $text-color; background: $body-bg-color;- +mobile() &#123; padding-left: 0 !important; &#125;- +tablet() &#123; padding-left: 0 !important; &#125; + +mobile() &#123; padding-right: 0 !important; &#125;+ +tablet() &#123; padding-right: 0 !important; &#125; +desktop-large() &#123; font-size: $font-size-large; &#125;&#125; 侧边栏目录展开侧边栏的TOC目录每次滑到哪儿，目录展开到哪。这样查看文章结构就很不方便，如何设置才能让文章目录默认全部都展开？在 主题配置文件 _config.yml 中修改配置toc ： themes/next/_config.yml123toc: wrap: false ## 如果标题超长，是否换行 expand_all: true ## 侧边栏是否完全展开]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT(v7.0+) 搭建博客：基础安装]]></title>
    <url>%2F2019%2F04%2F29%2Fhexo-satrted%2F</url>
    <content type="text"><![CDATA[关于如何搭建Hexo博客的文章已经有很多人写过了，并且有很多人已经写的很深刻很到位了，为什么还要重复写一遍呢？直到我看到了这位同学的博客 yearito （ ps：本站的建站优化大都参考自这里） ，我有了说服自己的理由： 你可以参考别人的技术方案，集众所长，亲自实践，然后融入自己的思考写出一篇新文章 即使并没有做出创新性的贡献，自己重新归纳一遍也有助于梳理流程，深化理解 现在百度 Google 很方便，动动手指就可以搜索到想要的答案，但是太多人都是**『顺手拈来、过目就忘』**，下次遇到同样的问题再搜索一遍。 为什么会这样呢？不善于总结，不情愿动手思考，时而久之就会变成所谓的 “代码搬运工” ！ 闲话不多说了，我们开始吧！ 安装node.js在 官方下载网站 下载源代码，选择最后一项 Source Code解压到某一目录, 然后进入此目录,依次执行以下 3 条命令 123$ ./configure$ make$ sudo make install 安装完后查看node.js版本，检验是否安装成功 1$ node -v 安装hexo在命令行中通过 npm 来安装 hexo： 1$ npm install -g hexo-cli 本地启动hexo创建一个博客目录（例如 /my-blog），在此目录下，执行初始化命令 123$ mkdir -p my-blog$ cd my-blog$ hexo init 执行完毕后，将会生成以下文件结构： 123456789101112.|-- node_modules //依赖安装目录|-- scaffolds //模板文件夹，新建的文章将会从此目录下的文件中继承格式|-- source //资源文件夹，用于放置图片、数据、文章等资源| |-- _posts //文章目录|-- themes //主题文件夹| |-- landscape //默认主题|-- .gitignore //指定不纳入git版本控制的文件|-- _config.yml //站点配置文件|-- db.json|-- package.json`-- package-lock.json 在根目录下执行如下命令启动hexo内置的web容器 12$ hexo generate # 生成静态文件$ hexo server # 在本地服务器运行 在浏览器输入IP地址 http://localhost:4000 就可以看到我们熟悉的** Hello Word **了。 常用命令简化和组合1234$ hexo g # 等同于hexo generate$ hexo s # 等同于hexo server$ hexo p # 等同于hexo port $ hexo d # 等同于hexo deploy 当本地不想使用默认的4000端口时（比如在服务器上，默认使用80端口），可以使用 port 命令更改启动端口另外，hexo支持命令合并，比方说 生成静态文件 → 本地启动80端口，我们可以执行 1$ hexo s -g -p 80 安装NexT主题hexo 安装主题的方式非常简单, 只需几个简单的命令即可。将NexT主题文件拷贝至themes目录下，然后修改 站点配置文件 _config.yml 中的 theme字段为next即可。 cd 到博客的根目录下执行以下命令下载主题文件： 12345$ cd my-blog$ git clone https://github.com/theme-next/hexo-theme-next.git themes/next$ vim _config.ymltheme: next 清除 hexo缓存，重启服务 12$ hexo clean$ hexo s -g 大部分的设定都能在 NexT官方文档 里找到, 如主题设定、侧栏、头像、友情链接、打赏等等，在此就不多讲了，照着文档走就行了。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SmartSpring框架 -- 01.框架介绍]]></title>
    <url>%2F2018%2F04%2F18%2Fsmartcity-frame-Introduction%2F</url>
    <content type="text"><![CDATA[框架的意义在于提高开发效率，统一开发模式，规范编码，减少重复工作，降低出错，提供必要的公共功能，同时需要易于集成、便于维护。 在搭建项目之时，需要引入依赖、配置框架，通常一些开源组件和配置不同版本之间会出现冲突问题。前端的模版化引擎会统一渲染接口返回值，这就要求服务端需要对异常信息和响应结果进行统一封装。为了加快项目开发进度还需要封装一些常用的类和工具包，比如 App Session管理、接口签名认证、参数验证、常用类型转换等等，有了这些项目才能正常开工。然而，下次再做类似的项目上述步骤可能还要重来一遍，虽然通常是拿来copy再改改，但是还是比较浪费时间的。所以可以利用面向对象抽象的思想，抽取这类项目的共同之处封装成了种子项目，再开发类似项目时可以直接在此之上迭代，减少无意义的重复工作。 功能概览 预定义常用开源组件依赖版本和插件配置信息，极大的简化了maven 配置 拦截Response的返回值，自动封装成 Result 类型 拦截RuntimeException异常，统一处理自动封装 代码自动生成，自动生成 Mybatis-mapper代码 简化参数校验流程 集中管理分布式应用的APP Session 根据 Token 认证增强 APP 接口安全性 利用 RedisClient 使用Redis缓存 自动执行SQL初始化脚本工具 开发环境 JDK 1.7 Maven3+ Oracle11g 技术选型 分类 技术选型 描述 开发框架 Spring 3.2.9.RELEASE 主流的轻量级JAVA开发框架 MVC框架 SpringMVC 3.2.9.RELEASE 优秀的的MVC框架，与Spring无缝集成 Restful框架 Jersey 2.6 主流的Restful框架 Restful框架 Resteasy 3.0.7.Final 主流的Restful框架 Restful Client Httpclient 4.5.3 HTTP 协议的客户端编程工具包 ORM框架 Mybatis 3.2.8 优秀的持久层框架 缓存方案 Spring Cache 3.2.9.RELEASE Spring带来的强大缓存技术 缓存连接 Jedis 2.4.1 分布式缓存数据库Redis的Java客户端框架 数据库连接池 Druid 1.0.5 阿里的数据库连接池框架 数据库驱动 ojdbc6 11.2.0.1.0 oracle数据库驱动 Servlet引擎 Jetty 6.1.26 轻量级的web服务器 servlet 引擎框架 Servlet引擎 Tomcat 7.0.57 最为广泛的 servlet 引擎框架 协调服务 Zookeeper 3.4.7 优秀的分布式协调服务框架 服务管理 Dubbo 2.5.3 阿里的分布式服务治理框架 网络编程 Netty 3.0.7.Final 广泛使用的Java网络编程框架 搜索引擎 Solr 5.5.2 基于Lucene的独立的企业级搜索引擎 搜索引擎 Elasticsearch 基于Lucene的分布式多用户的全文搜索引擎 消息队列 ActiveMQ 最流行的，能力强劲的开源消息队列框架 作业调度 Quartz 2.2.3 便于与Java项目集成的任务调度框架 文件系统 FastDFS 1.0.1 轻量级分布式文件系统 日志组件 slf4j 1.6.6 主流的日志系统统一的接口 校验框架 Hibernate Validator 4.2.0.Final 主流的校验框架 数据序列化 Gson 2.2.4 Json数据序列化框架 测试 Juint 4.8 单元测试框架 DOM dom4j 1.6.1 dom解析框架 富文本 Ueditor 1.1.1 富文本编辑器框架 包含模块 smart-spring-dependencies parent.pom，统一规划主要依赖开源组件和中间件版本，构建插件的版本和配置信息 smart-core 公共核心的Core包，定义公共的返回Result、异常、分页等类型以及工具类 smart-spring-support 封装常用功能，提供缓存处理、https请求、延时消息、定时任务等已成熟的实现方案 smart-spring-app-core 基于Jersey框架封装的Restful请求处理框架，实现了APP Session管理及接口权限验证 smart-spring-web-core 基于SpringMVC封装的请求处理框架，实现了Mybatis分页及自动执行SQL初始化脚本 后续计划 优化mybatis-generator 插件：实现批量生成和指定生成的功能 SQL初始化功能优化：支持版本迭代识别 一键生成初始化项目 环形队列&amp;延时任务处理 日志自动打印，自动归档 利用注解自动映射字典中文和日期格式 欢迎大家一起来参与完善smartSpring，期待您宝贵的建议！]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>smartSpring</tag>
        <tag>框架</tag>
        <tag>Spring</tag>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SmartSpring框架 -- 02.开发指南]]></title>
    <url>%2F2018%2F04%2F18%2Fsmartcity-frame-development-guide%2F</url>
    <content type="text"><![CDATA[设计思想 一个大型的分布式系统一般会包含多个应用，各个应用包含多端展现（移动端、wx端、web门户、后台管理），而且应用之间往往还存在共同的业务（上传、评论、支付、搜索），应用之间还会存在调用关系等。 因此，为了使业务得到很好的复用，模块更加容易拓展和维护，我们希望业务与应用分离。 应用层只包含前端展现和路由接口，服务层来实现具体业务，以供多端在不同场景下展现。 因此业务的接口需要具备通用性，可供多端多应用多场景使用，这对各位的设计能力来讲是一个考验（易用性、通用性、易拓展易维护）。 服务层被共享使用，会带来一些其它的挑战，比如业务并发压力等，考虑到性能、伸缩性、可用性和与Spring结合使用的技术成本，我们选择阿里的开源服务框架dubbo来解决这些问题， 由dubbo来提供服务治理功能，dubbo-api 提供接口，dubbo-service 提供业务服务。 ps：对于dubbo框架不了解的同学可以学习 http://dubbo.wangxingrong.com/User+Guide-zh.htm 这个时候有些同学不禁会疑惑，已经有Service业务层处理业务了，我们的biz层又是做什么的呢？ 聚合服务；我们有很多分布式服务（上文提到的评论、支付等），biz层的一个主要作用是把它们聚合起来，封装成一个与前端适配的接口 数据的格式化处理，满足各端应用对数据不同的表现形式。例如： 服务层有一个getUser的方法返回一个系统用户，其中有一个属性是gender（性别），对于服务层来说，它只从语义上定义：1-男，2-女，0-未知。 而接口服务同时给多端应用展现，不同展现层的要求有所不同（app端显示 1-帅哥，2-美女；web门户应用显示1-男性，2-女性），就会出现问题了。 再者，回到设计层面上分析，从职责单一原则来看，服务层只负责业务数据（返回 1，2，0）与具体的展现形式无关，因此它返回的数据不应该出现与展现形式的耦合。 程序分层 Controller/Restful（接口路由层）：接受前台请求和参数并返回，前台参数校验。 Biz（聚合层）：调用各类业务服务（Service），聚合数据并格式化。 Service（业务层）：调用各个数据库表数据（Dao），实现业务逻辑。 Dao（持久层）：调用SQL，操作数据库。 开发规范 基本规范：安装Alibaba Java Code Guidelines插件，检查代码规范性。 命名规范： Java类名、局域变量、类变量名、方法名采用标准驼峰命名，切勿出现单词拼写错误。 常量命名由大写字母与下划线组成，禁止简写。 数据库表名、字段名由小写字母加下划线组成。最多长度30个字母，允许适当使用简写。 除java文件以外的其他类型文件，包括xml、jsp、properties等由小写字母和横线组成。 SVN 使用规范： 切记避免提交不该提交的代码，例如构建生成的文件（.iml、.classpath等）。 提交SVN必须写备注，清晰规范并能正确描述所提交内容。 版本迭代完成之后将稳定版代码打Tags。 maven 使用规范： parent 项目pom.xml中使用dependencyManagement预定义整个项目所需的内部、外部依赖和配置信息，当项目升级时及时添加、更改。 属性值统一定义在properties中，便于集中维护。 开发中的版本号定义为SNAPSHOT，完成后升级为稳定版，下一阶段迭代开发时升级版本号。注意：项目交付时不能使用SNAPSHOT版本的jar包（特别是api.jar），以免后续的修改对已有上线项目造成影响。 GET/POST 请求使用规范： 搜索、查询、详情、显示等获取行为使用get。 提交、更新、删除等操作行为使用post。 数据模型定义规范： api接口层的数据模型，它是对外提供服务接口，为保护数据库数据结构，数据模型不可直接使用数据库映射的实体。 api接口数据模型的作用是应用层与服务层之间传递数据的对象，命名应以Dto（Data Transfer Object）结尾。 由于dubbo协议通常传输数据是二进制数据，也就是说你传递对象时对象将会被序列化，所以Dto对象一定要实现Serializable接口（可安装GenerateSerialVersionUID插件自动生成serialVersionUID），否则dubbo消费者调用会出错。 应用层的数据模型，它的作用是把某个指定页面的所有数据封装起来，因此把它定义为视图对象，命名应以Vo（View Object）结尾。 异常处理规范： 框架已对常见的Http异常进行了识别、处理和封装，无需再重复处理。 及时抛出业务产生的异常，即 BusinessException。 对可预见的异常以及RPC异常进行日志记录，以便于线上问题追踪。 参数合法性检查规范： 在应用控制层进行前端入参合法性校验，避免异常参数流向下一层造成业务异常，甚至事务无法回滚问题。 dubbo-api是提供给自身应用以及其他业务使用的对外接口，考虑到安全性和通用性，需在接口处（已融合Hibernate Validate框架，使用注解即可）做参数校验。]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>smartSpring</tag>
        <tag>框架</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SmartSpring框架 -- 03.开发说明]]></title>
    <url>%2F2018%2F04%2F18%2Fsmartcity-frame-development-description%2F</url>
    <content type="text"><![CDATA[本篇主要讲解项目的基本结构以及各个主要功能点的开发示例。 由于本项目主要使用阿里的Dubbo来做为开发架构，因此也可用于Dubbo开发者学习。 项目结构当我们使用这套框架搭一个初始化的项目亦或是一个成熟项目之后，它大概的结构是这样的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146.demo-parent |-- db-change ········································ 数据库表字段更改记录||-- startup ·········································· 启动脚本，部分项目可能无||-- demo-core ········································ 项目公共jar包，公共变量及方法，小项目舍弃 &lt;!-- more --&gt;| |-- src | | |-- main| | | |-- java | | | | `-- 包路径 | | | | |-- constants ···················· 公共常量目录，应用所需常量，不包含api常量| | | | `-- utils ························ 公用工具类目录 | | | `-- resources| | `-- test| `-- pom.xml ······································ 构建配置信息||-- demo-api ········································· 服务层接口，dubbo-api包，提供服务层接口| |-- src | | |-- main| | | |-- java| | | | `-- 包路径 | | | | |-- constants ···················· 常量目录，api对外常量 | | | | |-- api ·························· dubbo-api接口目录 | | | | `-- model ························ 接口出入参数模型目录，模型一般以Dto结尾| | | | |-- 模块1 | | | | `-- 模块2 | | | `-- resources| | | `-- dubbo ···························· duubo配置文件目录| | | `-- dubbo-consume-demo.xml ······· 提供给消费者的duubo接口，便于消费者集成| | `-- test| `-- pom.xml ······································ 构建配置信息||-- demo-app ········································· 应用层，restful接口war包，提供rest请求| |-- src| | |-- main| | | |-- java| | | | `-- 包路径 | | | | |-- base ························· 基本信息目录 | | | | | |-- config | | | | | | |-- RestConfig.java ······ jersry框架里Servlet的配置类，一般不修改| | | | | |-- Config.java ·············· 利用spring-bean对配置信息的映射类| | | | | `-- ReturnCode.java ·········· 异常信息的枚举 | | | | |-- biz ·························· 应用逻辑层目录，聚合接口，格式化参数| | | | |-- rest ························· 应用控制层目录，接收前端参数，校验合法性| | | | `-- vo ··························· 前后端交互的参数模型目录，一般以Vo结尾| | | | |-- 模块1 | | | | `-- 模块2 | | | |-- resources ···························· 项目资源目录| | | | |-- config ··························· 配置文件目录 | | | | | |-- local ························ 本地调试配置信息目录 | | | | | |-- dev ·························· 开发服务器配置信息目录 | | | | | |-- test ························· 测试环境配置信息目录 | | | | | `-- prod ························· 生产环境配置信息目录 | | | | |-- application-context.xml ·········· spring-bean的配置信息 | | | | |-- dubbo-consumer.xml ··············· dubbo消费者的初始化配置信息 | | | | `-- log4j.properties ················· log4j日志的配置信息 | | | `-- webapp ······························ war包的信息配置目录| | | |-- WEB-INF| | | | `-- web.xml ······················ web项目入口，初始化配置信息| | | `-- index.jsp ························ 项目初始化欢迎页| | `-- test| |-- jetty.xml ···································· jetty描述文件，一般不做修改 | |-- pom.xml ······································ 项目构建配置信息| `-- readMe.txt ··································· 部署说明，注意事项||-- demo-backend ····································· 应用层，项目后台管理系统war包| |-- src| | |-- main| | | |-- java| | | | `-- 包路径 | | | | |-- base ························· 基本信息目录 | | | | | |-- Config.java ·············· 利用spring-bean对配置信息的映射类| | | | | `-- ReturnCode.java ·········· 异常信息的枚举 | | | | |-- biz ·························· 应用逻辑层目录，聚合接口，格式化参数| | | | |-- controller ··················· 应用控制层目录，接收前端参数，校验合法性| | | | |-- filter ······················· 过滤器目录 | | | | | `-- LoginFilter.java ········· 登陆过滤器，管理登陆时的session信息| | | | `-- vo ··························· 前后端交互的参数模型目录，一般以Vo结尾| | | | |-- 模块1 | | | | `-- 模块2 | | | |-- resources ···························· 资源目录，同上，不再详细说明| | | | |-- config | | | | | |-- local | | | | | |-- dev | | | | | |-- test | | | | | `-- prod | | | | |-- application-context.xml | | | | |-- dubbo-consumer.xml | | | | `-- log4j.properties | | | `-- webapp| | | |-- resources ························ 前端静态资源目录| | | |-- views ···························· jsp文件目录| | | | |-- 模块1| | | | |-- 模块2| | | | `-- error ························ 异常请求jsp文件目录| | | |-- WEB-INF ························· war包的信息配置目录| | | | `-- web.xml ······················ web项目入口，初始化配置信息| | | `-- index.jsp ························ 初始化欢迎页jsp| | `-- test| |-- jetty.xml ···································· jetty描述文件，一般不做修改 | |-- jetty-env.xml ································ jetty的配置文件，一般配置数据库连接信息| |-- pom.xml ······································ 构建配置信息| `-- readMe.txt ··································· 部署说明，注意事项||-- demo-web ········································· 应用层，项目web门户系统war包，类同backend|`-- demo-service ····································· 业务层，dubbo-service包，实现api接口 |-- src | |-- assembly ································· 打包配置目录 | | |-- bin ·································· 启动脚本目录 | | | |-- run.bat ·························· windows环境启动脚本 | | | |-- run.sh ··························· linux环境启动脚本 | | `-- assembly.xml ························· service打包配置信息，一般不做修改 | |-- main | | |-- java | | | `-- 包路径 | | | |-- base ························· 基本信息目录 | | | | |-- Config.java ·············· 利用spring-bean对配置信息的映射类 | | | | |-- Constants.java ··········· 常量类，提供本子项目所需使用的常量 | | | | `-- ReturnCode.java ·········· 异常信息的枚举 | | | |-- dao ·························· 业务持久化层，调用sql，操作数据库 | | | |-- entity ······················· 数据库表对应映射的实体类 | | | |-- service ······················ 业务实现层，api接口的实现 | | | |-- InitApplication.java ········· 应用初始化类，在容器初始化后调用 | | | |-- Provider.java ················ dubbo的启动类，运行main方法启动项目 | | `-- resources | | |-- config ··························· 配置文件目录 | | | |-- local | | | |-- dev | | | |-- test | | | `-- prod | | |-- mapper ··························· Mybatis映射的xml文件目录 | | |-- META-INF ························· jar包的信息配置目录 | | | `-- spring ······················· spring配置信息目录 | | | |-- dubbo-provider.xml ······· spring-bean的配置信息 | | | `-- spring-context.xml ······· duubo提供者的初始化配置信息 | | |-- sql ······························ 初始化sql存放目录 | | | |-- initTabel.xml ················ 初始化表结构sql | | | `-- initDate.xml ················· 初始化表数据sql | | |-- log4j.xml ························ log4j日志的配置信息 | | |-- generatorConfig.xml ·············· mybatis反向生成代码配置文件 | | |-- mybatis-generator.properties ····· mybatis反向生成代码配置信息 | | `-- mybatis-config.xml ··············· mybatis配置信息 | `-- test |-- pom.xml ······································ 构建配置信息 `-- readMe.txt ··································· 部署说明，注意事项 开发示例注：素材侧重于举例说明使用方法，有诸多不规范的地方（注释内容，硬编码等），请勿完全参照。 1. 定义常量&amp;枚举12345678910111213141516171819202122232425262728public interface CommonEnum &#123; /** * 单属性 */ enum Check implements StateEnum &#123; /** 0 否 ，1 是 ，2 未通过 */ TRUE(1), FALSE(0), NO_PASS(2); &#125; /** * 多属性 */ enum State implements ServiceEnum &#123; DISABLE(0, "已禁用"), ENABLE(1, "已启用"), DELETE(2, "已删除"); /** 状态 */ private Integer state; /** 状态中文解释 */ private String text; State(Integer state, String text) &#123; this.state = state; this.text = text; &#125; &#125; &#125; 2. 定义异常返回值123456789public enum ReturnCode implements IReturnCode &#123; PARAM_NULL_ID(41001, "missing id"), PARAM_INVALID_ID(41007, "invalid id"); private int code; private String message; // 其余代码略 &#125; 实现IReturnCode接口，添加异常业务类型（code，message） 如项目有core包，可全部定义在core中，避免重复业务 抛出异常有助于自己排查问题，也便于前端人员定位问题* 3. 定义 dubbo-api 定义接口类和接口方法，在api包 resources.dubbo 文件夹下dubbo-consume-demo.xml 中声明接口 1234567891011public interface DemoService &#123; /** * 打招呼 */ String sayHello(@NotBlank String name); /** * 获取Demo */ DemoDto getDemo(@NotBlank Integer age);&#125; 12&lt;dubbo:reference id="demoService" interface="包路径.DemoService" protocol="dubbo" version="$&#123;dubbo.service.version.demo&#125;" validation="true"/&gt; validation为可选属性，缺省值是false，建议开启。开启验证后 Hibernate Validator 注解生效，会对接口参数进行校验 4. dubbo-Service实现dubbo-api12345678910111213141516@Service("demoService")public class DemoServiceImpl implements DemoService &#123; @Autowired private DemoDao demoDao; @Override public String sayHello(String name) &#123; return "Hello , " + name + " !"; &#125; @Override public DemoDto getDemo(Integer age) &#123; return demoDao.getDemo(age); &#125;&#125; @Service注解后指定 &lt;bean id&gt;（与api.xml中定义的id需相同），spring.context.component-scan 扫描后即可自动托管bean对象 5. 配置服务提供者 在 pom.xml 中依赖 api-jar 包 在 resources.META-INF.spring 目录（缺省目录）内新建配置文件dubbo-provider.xml 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd" default-lazy-init="true" default-autowire="byName"&gt; &lt;description&gt;Dubbo提供者配置&lt;/description&gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name="$&#123;dubbo.provider.application.name&#125;"/&gt; &lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt; &lt;dubbo:registry address="$&#123;dubbo.registry.address&#125;" check="false" timeout="$&#123;dubbo.registry.timeout:30000&#125;"/&gt; &lt;!-- 调用超时时间 和 服务版本信息 --&gt; &lt;dubbo:provider timeout="$&#123;dubbo.provider.timeout:30000&#125;" version="$&#123;dubbo.service.version&#125;"/&gt; &lt;!-- 定义服务所用协议信息-dubbo协议 --&gt; &lt;dubbo:protocol name="dubbo" port="$&#123;dubbo.dubbo.port&#125;"/&gt; &lt;!-- 声明服务提供者接口 --&gt; &lt;dubbo:service interface="包路径.DemoService" ref="demoService" validation="true" retries="0" protocol="dubbo"/&gt;&lt;/beans&gt; retries为可选属性，缺省值是2，设置为0后可避免服务堵塞情况下自动重试导致事务问题。 6. 启动服务提供者 运行 Provider.java 内的main()方法即可启动消费者 更改 src.assembly.bin 目录内启动脚本中APP_MAINCLASS的路径为 Provider.java 7. 配置服务消费者 在 pom.xml 中依赖 api-jar 包 在 resources 目录内新建配置文件dubbo-consumer.xml，并托管给Spring管理（在web.xml*配置或者 *application-context.xml 配置都可以） 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd" default-lazy-init="true" default-autowire="byName"&gt;&lt;!-- 消费方应用名，用于计算依赖关系 --&gt;&lt;dubbo:application name="$&#123;dubbo.application.name&#125;"/&gt;&lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt;&lt;dubbo:registry address="$&#123;dubbo.registry.address&#125;" check="false" timeout="$&#123;dubbo.registry.timeout:3000&#125;"/&gt;&lt;!-- 远程服务调用超时时间，是否检查 --&gt;&lt;dubbo:consumer timeout="$&#123;dubbo.consumer.timeout:3000&#125;" check="false"/&gt;&lt;!-- 引入其他api包中的配置文件，声明其提供的所有接口 --&gt;&lt;import resource="classpath*:/dubbo/dubbo-consumer-demo.xml"/&gt;&lt;!-- 声明欲使用的接口 --&gt;&lt;dubbo:reference id="commentService" interface="包路径.CommentService" protocol="dubbo" version="$&#123;dubbo.service.version.comment&#125;" validation="true"/&gt;&lt;/beans&gt; 在配置文件中配置各项属性，有默认值的可不再重复配置 registry中check属性是检查注册中心是否正常 consumer中check属性时检查对应服务是否正常注册 接口如果不是全部需要使用建议单独声明需要的接口，无效声明过多引起连接资源浪费 8. 完成 Restful 接口1234567891011121314151617181920212223242526@Path("/demo")@Produces(MediaType.APPLICATION_JSON)@Componentpublic class DemoRestful &#123; @Path("/a") @GET @AppAuthorization public String demo(@PathParam("name") String name, @PathParam("age") Integer age) &#123; // 校验参数，抛出自定义的异常 if (ParamVerifyUtil.isEmpty(id)) &#123; throw new IllegalParamsException(ReturnCode.PARAM_INVALID_ID); &#125; // 校验参数并自动抛出统一异常 ParamVerifyUtil.verifyEmpty(age); // 使用AppAuthorization注解后，可通过以下方法获取userId String userId = BasicContext.get().getUserId（）; // 调用biz接口 xxBiz.xx(); return “hello word”; &#125;&#125; 在方法上加注注解 @javax.ws.rs.GET/@javax.ws.rs.POST ，声明请求方式 get请求对用的参数注解为 @QueryParam post请求对应的参数注解为 @FormParam 如果请求体是文件流，应在方法上加注注解 @Consumes(MediaType.MULTIPART_FORM_DATA) 如果需要对请求权限进行验证，需要加上自定义App权限验证注解@AppAuthorization， 使用后框架会对请求进行验证，并根据入参token解析userId 两种校验参数方式根据业务自由选择，入参均支持常用数据类型ps: jersey框架与Hibernate Validator框架融合时有版本兼容问题，暂未解决，所以暂时使用手动验证。 如果请求参数过多，可封装成实体类，使用注解 @BeanParam标注实体，实体类的各个参数需加对应请求的注解 @QueryParam or @FormParam ，例如： 123456789101112@POSTpublic String demo(@BeanParam DemoFormVo demo) &#123; return "hello word";&#125; public class DemoFormVo &#123; @FormParam private Integer age; @FormParam private String name;&#125; 9. 完成Controller 接口123456789101112131415161718@Controller@RequestMapping("/demo")public class DemoControlle &#123; @ResponseBody @RequestMapping(value = "/demo", method = RequestMethod.GET) public String demo(@Validated @ModelAttribute DemoFormVo demo) &#123; return "hello word"; &#125;&#125; public class DemoFormVo &#123; @Max(value = 150) private Integer age; @NotBlank private String name;&#125; 使用方式与Restful接口类似，不同的是注解使用SpringMVC的注解 实体类的注解使用@ModelAttribute，且不在需要加注参数注解 使用 Hibernate Validator 框架的注解进行参数合法性验证 10. 完成biz层逻辑12345678910111213141516171819202122232425262728293031@Servicepublic class DemoBiz &#123; @Autowired private DemoService demoService; @Autowired private CommentService commentService; public DemoVo demo(DemoFormVo form) &#123; // 调用demoService接口 DemoDto dto = demoService.getDemo(form.getName()); // 识别业务异常，及时抛出 if(dto == null)&#123; logger.error（“xx业务异常”）； throw new BusinessException(ReturnCode.PARAM_NULL_ID); &#125; // 通过GsonUtil转换得到DemoVo DemoVo vo = GsonUtil.convert(dto, DemoVo.class); // 调用其他dubbo-api接口 Comment comment = commentService.getComment(form.getAge()); // 封装返回值 vo.setComment(comment); return vo； &#125;&#125; 及时识别业务异常，记录日志并抛出 11. 使用Redis缓存 在application-context.xml*中引入bean配置 `&lt;import resource=”classpath:cache/*.xml”/&gt;` ，并在配置文件中配置以下属性 redis.host redis.port redis.database redis.password redis.maxIdle 连接池状态为idle的实例个数，缺省值300，可不配置 redis.maxWait 连接池最大等待时间（s），缺省值3000，可不配置 redis.maxTotal 连接池最大连接数，缺省值50，可不配置 调用RedisUtils工具类里封装的方法即可。 12. 处理自定义异常 在web.xml 里配置SpringMVC的servlet-class。 缺省配置的处理异常 class 为 com.iflytek.sgy.social.web.core.exception.ExceptionDispatcherServlet 如果需要处理自定义异常（注：此功能在 V 0.5.0版本后方可使用），则需要编写实现类继承com.iflytek.sgy.social.web.core.exception.AbstractExceptionDispatcherServlet，重载handleOtherException()方法，覆盖缺省配置。 1234567891011121314public class PayExceptionDispatcherServlet extends AbstractExceptionDispatcherServlet &#123;@Overrideprotected Result handleOtherException(Exception ex) &#123; if (ex instanceof PayErrorException) &#123; logger.error(" ========== pay error ========== ", ex); IPayError error = ((PayErrorException) ex).getPayError(); ReturnCode returnCode = error.getPayError(); // 返回失败结果 return Result.fail(returnCode.getCode(), returnCode.getErrorMsg()); &#125;&#125; 13. 实现集中管理 APP Session注：此功能在 V 0.5.0版本后方可使用。 实现接口com.iflytek.sgy.social.app.core.base.TokenTemplate，重载抽象方法 123456789101112131415161718192021222324252627282930313233343536373839@Componentpublic class AppToken implements TokenTemplate &#123; /** * 获取token * @param userId 用户UUID */ @Override public String getToken(String userId) &#123; return null; &#125; /** * 从token中解析userId * @param token TOKEN */ @Override public String parseToken(String token) &#123; return null; &#125; /** * 生成token * @param userId 用户UUID */ @Override public String makeToken(String userId) &#123; return null; &#125; /** * 销毁token * @param userId 用户UUID */ @Override public String destroyToken(String userId) &#123; return null; &#125;&#125; 在 application-context.xml 里加上配置 123456&lt;import resource="classpath*:aop/*.xml"/&gt;&lt;!--配置token管理的实现--&gt;-&lt;bean id="appToken" class="包路径.AppToken"/&gt;&lt;bean class="com.iflytek.sgy.social.app.core.base.TokenManager" p:tokenTemplate-ref="appToken"/&gt; 更改web.xml 里servlet-class 为 com.iflytek.sgy.social.app.core.extension.ServletContainer 14. 自动执行SQL初始化脚本注：此功能在 V 0.5.0版本后方可使用。 实现ApplicationListener接口，重载onApplicationEvent()方法，在方法里调用executeSqlInit() 12345678910111213@Componentpublic class InitApplication implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123; @Autowired private ExecuteSqlDao executeSqlDao; @Override public void onApplicationEvent(ContextRefreshedEvent event) &#123; // 获取ExecuteSqlDao实例，调用执行sql初始化方法 ExecuteSqlEvent.getInstance(executeSqlDao).executeSqlInit(); &#125;&#125; 在 resources.sql 目录下建立 initTable.xml（初始化建表）和 initData.xml（初始化数据） 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;tables&gt; &lt;table&gt; &lt;!-- 表名，例如T_NAFC_RESOURCE --&gt; &lt;check&gt;T_TABELE_NAME&lt;/check&gt; &lt;sql&gt; &lt;/sql&gt; &lt;/table&gt;&lt;/tables&gt; check标签是表名 sql标签是待执行sql，建表语句 or 数据初始化语句 15. 配置常用maven插件注：此功能在 V 0.5.0版本后方可使用。 dubbo-service 定制化打包插件已预定义直接使用即可 123&lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;&lt;/plugin&gt; jetty 插件和 tomcat 插件已预定义直接使用即可，缺省端口是8090，如需改变请覆盖配置 1234567891011121314151617&lt;properties&gt; &lt;jetty.port&gt;8091&lt;/jetty.port&gt; &lt;tomcat.port&gt;8092&lt;/tomcat.port&gt;&lt;/properties&gt;&lt;plugins&gt; &lt;!-- jetty插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt; &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;tomcat-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt;&lt;/plugins&gt; 16. 打包发布 根据环境执行不同环境的打包命令，不同环境对于不同的log过滤等级。 命令 mvn clea package -Pdeploy local – DEBUG dev – DEBUG test – INFO prod – ERROR deploy – ERROR 注：以下功能在 V 0.5.0版本后方可使用。 除local环境打包后读取classpath下的配置文件，其他环境默认读取/iflytek/zhcs/config/目录下的配置， 如需读取其他目录，可在pom.xml里覆盖配置 environment.path]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>smartSpring</tag>
        <tag>框架</tag>
        <tag>Dubbo</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SmartSpring框架 -- 04.接口说明]]></title>
    <url>%2F2018%2F04%2F18%2Fsmartcity-frame-interface-description%2F</url>
    <content type="text"><![CDATA[工具接口说明DateUtil时间转换工具类（com.xxx.core.util.DateUtil） 字段概要 限定符 类型 字段 说明 static String DATE_FORMAT_HH_MM HH:mm static String DATE_FORMAT_YYYY_MM_DD yyyy-MM-dd static String DATE_FORMAT_YYYY_MM_DD_HH_MM yyyy-MM-dd HH:mm static String DATE_FORMAT_YYYY_MM_DD_HH_MM_SS yyyy-MM-dd HH:mm:ss static String DATE_FORMAT_YYYYMMDD yyyyMMdd static String DATE_FORMAT_YYYYMMDDHHMMSS yyyyMMddHHmmss 方法概要 返回类型 方法 说明 String dateToDateStr(java.util.Date date) Date转换为日期字符串:yyyy-MM-dd String dateToSimpleTimeStr(java.util.Date date) Date转换为时间字符串:yyyy-MM-dd HH:mm String dateToStr(java.util.Date date, java.text.SimpleDateFormat sdf) 时间转换为字符串:sdf String dateToTimeStr(java.util.Date date) Date转换为时间字符串:yyyy-MM-dd HH:mm:ss String dateToTimeXXStr(java.util.Date date) Date转换为时间字符串:yyyyMMddHHmmss String formatDate(java.util.Date date, java.lang.String format) 日期转换,自定义格式 String formatDateStringWithDot(java.lang.String timeStr) 处理从数据库查询的日期串带 .0的情况 Date formatIdentifyIdToBirthday(java.lang.String identifyId) 将身份证转换为生日Date String friendlyFormat(java.util.Date date) 友好的方式显示时间 , 默认不是当天显示 yyyy-MM-dd HH:mm String friendlyFormat(java.util.Date date, java.lang.String pattern) 友好的方式显示时间 String friendlyFormat(long dateLong) 友好的方式显示时间 , 默认不是当天显示 yyyy-MM-dd HH:mm String friendlyFormat(long dateLong, java.lang.String pattern) 友好的方式显示时间 String friendlyFormat(java.lang.String str) 友好的方式显示时间 , 默认不是当天显示 yyyy-MM-dd HH:mm Date getAfterDays(java.util.Date date, int days) 获取某日期之后X天的日期 Date getBeforeDays(java.util.Date date, int days) 获取某日期之前X天的日期 Date getDate() 获取当前时间:Date int[] getDatetimeArray(java.util.Date date) 获取某时间的 年月日时分秒 List getMonthDays(int year, int month, java.lang.String format) 获取指定年月的所有天数的字符串集合 String getWeek(java.lang.String dateStr) 判断一个日期是星期几 Integer getWeekDay(java.lang.String dateStr) 根据时间格式获取时间当前星期 boolean isBeForeNow(java.lang.String formatDate) 判断时间是否是当前时间之前 ,当天不算 boolean isDate(java.lang.String dateStr) 判断字符串是否为时间格式 Date parseDate(java.lang.String dateStr, java.lang.String format) 日期转换,自定义格式 Date strToDate(java.lang.String str) 字符串转换为日期:yyyy-MM-dd Date strToTime(java.lang.String str) 字符串转换为时间: yyyy-MM-dd HH:mm:ss Date strXXToTime(java.lang.String str) 字符串转换为时间: yyyyMMddHHmmss String timeStrToDateStr(java.lang.String str) 字符串由时间格式转换为日期格式: yyyy-MM-dd HH:mm:ss → yyyy-MM-dd Integer transferBirthdayToAge(java.util.Date birthday) 根据时间得到年龄]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>smartSpring</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SmartSpring框架 -- 05.常见问题]]></title>
    <url>%2F2018%2F04%2F18%2Fsmartcity-frame-common-problem%2F</url>
    <content type="text"><![CDATA[Q : 返回值 code 400405A : GET/POST请求使用错误。 Q : 消费者调用了别人的提供者服务，导致调试困难A : 这是怎么造成的呢？服务版本号设置是dubbo.service.version= 0.5_${user.name}，只要user.name不同，理论上是不会存在交叉调用情况的； 但这个user.name其实是操作系统当前登陆的用户名，大多数人都是Administrator用户登陆的， 因此会出现版本号相同的情况，dubbo默认的负载均衡策略为Random Loadbalance（随机均衡算法），此时就有可能调用到其他人的服务了。怎样避免这种情况发生呢？修改 user.name 123找到IDEA的安装目录，比如 C:\Program Files\JetBrains\IntelliJ IDEA 2017.2.3\bin 用文本编辑器打开idea.exe.vmoptions（win32bit）和idea64.exe.vmoptions（win64bit），新建一行添加-Duser.name=your name Q : service 项目启动时，日志不停刷新内容：asyncTotalCount: {false}12paginator.PageInterceptor - dialectClass: &#123;***.paginator.dialect.OracleDialect&#125; paginator.PageInterceptor - asyncTotalCount: &#123;false&#125; A : 这是由于Mapper.xml中分页的sql有错误，检查近期提交的sql，特别是parameterType和resultType Q : service 项目启动时报错 object is not an instance of declaring classA : 这是由于接口类没有暴露方法，导致服务没有实例化。 Q : 调用 dubbo-service 提供者的接口时报错 Failed to invoke the method12com.alibaba.dubbo.rpc.RpcExeptiom:Failed to invoke the methodcom.alibaba.dubbo.rpc.cluster.support.FailoverClusterInvoker.doInvoke(FailoverClusterInvoker.java:101) A : 这是由于在zookeeper中没有找到服务提供者，请检查服务提供者是否正常启动、服务版本号是否正确、接口参数类型是否正确。 必要时可参考dubbo-admin控制台信息。 Q : 部署在 linux服务器上，service服务在zookeeper上注册的地址与服务器地址不一致。A : 可能是hosts ip 或者 DNS 设置错误 检查/etc/sysconfig/network中的 HOSTNAME 与 /etc/hosts中的 ${HOSTNAME} 对应的 hosts ip地址是否正确； 检查/etc/resolv.conf中的 nameserver 对应的DNS地址是的正确。 Q : service*服务出现异常 *java.io.IOException: Connection reset by peerA : 出现 Connection reset by peer 原因可能是多方面的，不过更常见的原因是 服务器的并发连接数超过了其承载量，服务器会将其中一些连接Down掉； 客户关掉了浏览器，而服务器还在给客户端发送数据； 解决方法是：修改zookeeper安装目录下 conf/zoo.cfg文件。将maxClientCnxns参数改成更大的值。 Q : ajax请求接口返回信息是空，基本信息 flag、code、message都没有A : SpringMVC框架返回值为null时，无法对返回值进行Result对象封装，请注意！]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>smartSpring</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SmartSpring框架 -- 06.升级计划]]></title>
    <url>%2F2018%2F04%2F18%2Fsmartcity-frame-upgrade-plan%2F</url>
    <content type="text"><![CDATA[V 0.5.0-SNAPSHOT初始化版本，完成时间 2017-07-20 技术选型落地，规范开发流程和项目结构 在pom.xml里预定义常用开源组件依赖版本 拦截Response的返回值，自动封装成 Result 拦截RuntimeException异常，统一处理自动封装 融合 Hibernate Validator 验证框架，简化参数校验流程 初始化常用工具类，包含字符处理、集合处理、参数验证、时间格式、Json处理、SQL过滤等 V 0.5.0第一个迭代版本，完成时间 2018-04-08 增加了插件配置信息和环境配置信息预定义 集中管理分布式应用的APP Session 根据 Token 认证增强 APP 接口安全性 支持处理自定义异常 自动执行SQL初始化脚本 支持自定义打包环境路径 V 0.5.1优化0.5.0版本中提出的问题，进行中…… 为 APP 接口安全性验证增加一个开关，方便开发调试 优化 mybatis-generator 插件：实现批量生成和指定生成的功能]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>smartSpring</tag>
        <tag>框架</tag>
      </tags>
  </entry>
</search>

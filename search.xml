<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[再见，2019]]></title>
    <url>%2F2020%2F01%2F19%2F%E5%86%8D%E8%A7%81%EF%BC%8C2019%2F</url>
    <content type="text"><![CDATA[再见，2019明天就回家了，今天正好有时间，那就总结总结2019年吧！ 放假了才知道自己的自律能力还是很差，虽然有时间，有很多事，但就是提不上劲学习。一定缺失学习氛围，嗯，就是！这个锅可以甩！ 一年又过去了。现在已经研二过半，明年就要考虑找工作的事情，说实话，现在还是优点迷茫。总结去年也写过，但是写的内容都是拼拼凑凑，貌似流水账，逻辑那叫一个乱。今年开始写博客了，所以年终总结也不能落下，毕竟，今天闲的！ 2019年，本命年，算是我人生中比较多姿，也坎坷的一年吧。四季都一些事情发生，很多事情慢慢变成了过去，但是于我而言，回顾一年的经历，哪些地方做得还行，哪些地方需要改进，对自己的提升也是有很大帮助的。 2019之原罪开篇必须先言其短！ 今年越发感觉时间不够用了。一方面是自己时间管理能力差；另一方面也是源于自己的懒惰。每天花了很多时间在学习，但是产出很低，整个人一天都没有什么精神。每一天只是看似过的很充实，总是感觉心里欠缺点东西。现在回忆过去的一年内发生的事情，很多画面想诉诸笔端，却无从下笔。 1）读书太少。读书可以提升一个人的内涵，增加知识面，更有助于提升气质。在我的桌子上，技术类的书籍占据了99%，文学类的书籍屈指可数，明年需要多读一些非技术类的书籍。 2）运动频率低。在实验室一坐就是一整天，坐着的时间长达8小时，虽然手环设置了“久坐提醒”，哎，可是大部分时候正在看视频或打字，不想动弹。长时间看着电脑，眼睛累的不行，所以去吃饭或者在路上的时候都把眼镜摘掉（因为这个原因，有时候朋友碰到了打招呼，我都没有注意到，我真不是故意的！）晚上睡觉已经好久不睡枕头了，平坦着感觉脖子好舒服啊！但因为脑袋直接搁在床板上，时间长了，有段时间头疼的不行哦！ 3）表达能力差。平时与人交流，脑中的想法和我表述的大相径庭，逻辑很乱，永远不知道自己在说什么。喜怒哀乐也统统摆在脸上，遇到讨厌的人或事，就喜欢直怼。有时候事后回想，都感觉自己幼稚，太不成熟了。 4）坚持在哪里。很早之前就打算写博客，记录学习中的关键点和生活的点滴，一个月又一个月，每次刚写一点就感觉麻烦，坚持不下去。今年借助GitHub搭建了个人博客，可以废弃了很久，并没有怎么更新。定了每周更新一篇的计划也没有执行。 5）缺乏面对疾风的心态。不管是学习上的困惑，还是生活中的坎坷，总是向着逃避，不敢正视问题本身。尤其在事情接踵而来，应接不暇时，常常容易宕机，然后选择逃避，彻底放纵自己，再次面对时还是一筹莫展。现在还是在学校，以后工作，问题更是来自四面八方，所以学会面对疾风吧！ 喝口水，接着。。。 运动2019年年初本来计划每周运动一次，去操场跑几圈，然而Flag不到一周就倒了，夏天太热，冬天太冷，不过，最主要的原因是操场太远，哈哈哈！下半年变成了一个月跑步一次，11月学校有个酷跑迷你马拉松，5Km的，一时兴起参加了，哎，长时间不锻炼，跑完累死了。好在最后还是坚持下来了！ 2020，不管如何，还是要多锻炼，毕竟身体是自己的，天天对着电脑，不仅对眼睛不好，坐着也对腰不好。计划就不定了，我每次定的计划很少能执行完的。 睡眠有个手环看着自己，还是不错的！先看看有了手环之后的睡眠记录吧。 深睡的时间比较少，睡眠时间也比较晚，大多在12点左右，中午必须补充睡眠，不然下午完全废了，无精打采的。虽然知道熬夜对身体不好，但是身不由己啊，现在身体有点不舒服，该警惕了。之前看到这样一段话： *知道后来才发现，* *熬夜是缓解压力的一种方式。* *爸妈都睡了，老师都睡了；* *喜欢的人也睡了，全世界都睡了；* *不用再去担心什么事情了。* *用这好不容易偷来的时光，赶紧做点自己喜欢的。* 的确，这很符合我内心的独白。有时候，就是喜欢安静了自己一个人去考虑一些事情。很多朋友说我不怎么说话，有时候我变得话多了，都不认识了。我表现的沉默寡言的时候，心里有事情困扰，只想静静地理清思路。 #### 游戏 说实在的，游戏偶尔凑凑热闹，还是挺开心的，王者很适合解乏。晚上回宿舍与室友一起开黑，感觉挺爽！有时候排位，哎，猪一般的队友，打的想投降。王者里面我比较喜欢法师和刺客，喜欢那种一套带人走的感觉。时间精力有限，但是这几天，天天沦陷在峡谷。谁让之前一路飙升，赶紧人生达到了巅峰呢！ 游戏，玩的就是开心，输赢不需要太在意！ #### 华为网挑赛 19年4月份，过完清明节，参加了华为网络精英挑战赛，本来只是闲着无聊，冲着华为去的。比赛共三轮，初赛当时自己是有点把握的，虽然内容很多，时间比较紧，但是40%的过关率，相信自己不会太差。果然，进了复赛。复赛要到华为上海研究所，不得不说，华为真的是在举办比赛，服务太周到了，比赛过程水果无限量供应，中午的菜更是丰富，菜都没上完，我们就吃饱啦！ 比赛挺紧张的，因为我们组是上午集体面试，下午上机操作。所以等待时，闲聊发现，周围都是上交、负担、同济、中科大的，还有博士生，大部分都是研二，只要几个和我一样的研一的和大四的。当时心里慌得一匹，毕竟我那么菜。 一直等这上一组结束，紧张的我去了次厕所，回来发现人都进去了。哎，当时刚坐下时更是不知所措。集体面试是分为两个小组，小组讨论，然后双方对抗，阐述自己方案的合理性。这个从来没有经历过，所以小组讨论刚开始，我没有怎么说话。还和我们组的方案设计产生了分歧，他们不认可我的意见，哎。 讨论结束，面试官问我们组方案时，我也不知道自己哪来的勇气，站起来说出了自己想法，以至于对面小组，后面还表示他们组内意见统一，哎，我貌似给我们组背后插了一刀。不过，我真的是有充分的理由坚持自己的方案。全程我都很紧张，不停地在记录对方的方案，寻找缺陷，终于找到一个点，在关于新技术的使用上存在安全隐患问题，新技术还不完善，存在一些漏洞，但是效益巨大。我突然想到AWS与IBM的案例，我觉得能充分说明这个问题，阐述完自己的想法，感觉爽翻了。最后，面试官还夸了我，台风不错。哇，开心！这是我吗,哈哈哈！ 下午上机操作，时间紧迫，最后还是存在一些问题，但是大部分做出来了。比赛结束HR带我们参观了华为上研所，当时真的没有心情参观，紧张比赛结果。结果真的出乎我的意料，进入前10了，还有奖品，华为B5手环，香～还有面试绿卡唉！最重要的是，进入决赛了，而且还是去深圳，华为总部。 复赛到决赛，时隔一个月，难度更大。决赛的场面挺大，全国的选手都需要过去，优秀的人真的太多了，最后的冠军队伍组合无敌了，国防科大、湖大、中南、澳大利亚，其中还有个博士，太强了！赛程最后一天是参观华为松山湖基地，欧洲风格，真的好漂亮！仿照欧洲著名的建筑物建造了，转了一圈，真的很想在那里工作。最后在喜来登度假酒店举办的晚宴，第一次在沙滩浪，这个世界真的有比基尼小姐姐，那里的海水比之前去东极岛的好多了，能够下海玩。 晚宴我们组两队，10个人，哎，不开心啊，没获奖，所以借酒浇愁。整个晚宴，我们这桌喝的就最多，大概要了八九瓶红酒，真的开心啊！华为真的在举办比赛。还想参加！ 德国汉诺威学校有个海外交流的项目，是去德国汉诺威大学。我觉得，要多走走，多看看，如果只是拘泥于上海，拘泥于国内，世界有太多的精彩会错过。 一个月的生活，认识了一些很好的朋友，自己做饭，我发现，我是个大厨！顶级厨师，嗯！ 德国的生活环境还是比较喜欢的，安静，一切看上去不是那么忙碌！外国人很懂得生活，国内的生活给人的感觉就是很浮躁，为了工作，为了薪水，为了家庭，感觉风风火火的。外国人的素质，不得不说挺好的，我比较喜欢那种环境。 感触比较深的就是垃圾分类和空瓶子回收，垃圾分类做的很好，回国之后，上海也开始实行垃圾分类了，但是刚起步还需要慢慢来！德国的超市门口有一个瓶子回收的机器，有些瓶子是可以回收的，然后给你一张小票，买东西时可以折现。我们发现这个秘密后，每次上完课，教授发给我们的矿泉水瓶都收好，我们组的加起来快2欧了，然后买点菜回去，没办法，穷啊，外国的菜太贵了。 最后是从法国回上海的，参观了卢浮宫，凯旋门，可以那时候我手机坏了，不能拍照。卢浮宫真的得壮观，收藏的展品，让人叹为观止！有个阿波罗神殿，本来想看，但是维护中看不了，不过看见了蒙娜丽莎的微笑，哈哈哈，人真的好多，乌压压一片！ 。。。写不动了，饿死了，快点收尾，我要去吃饭！（肚子的旁白） 下次，哎，不会了，一旦放下，不会在写的。 计划面对在下一个十年，2020年，希望能够做到下面六点： 每月至少一篇高质量博文； 练习吉他，能够达到solo效果； 一场轻松的旅行，目标四川； 坚持锻炼，每周坚持跑步（但愿Flag不要倒）； 每天坚持一道算法题，锻炼思维； 能集中解决很多困惑，形成自己的原则与思维方式，并开始学着拒绝！ 2020年，一切又从零开始。 不乱于心，不困于情，不畏将来，不念过去，平静，便好！相 信前方一定会有另一番不同的风景，善待自己！ 祝大家新年快乐，元旦快乐！]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F12%2F26%2FGDBT%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Qt—QSS样式表]]></title>
    <url>%2F2019%2F10%2F07%2FQtQSS%2F</url>
    <content type="text"><![CDATA[​ Qt样式表的概念、术语和语法都受到HTML的层叠样式表（CSS）的启发，不过Qt样式表应用于部件的世界。 ​ 样式表可以使用QApplication::setStyleSheet()函数将其设置到整个应用程序上，也可以使用QWigdget::setStyleSheet()函数将其设置到一个指定部件上。如果在不同的级别都设置了样式表，那么Qt会使用所有有效的样式表，这被称为样式表的层叠。 1 样式规则​ 样式表包含了一系列的样式规则，每个样式规则由选择器和声明组成。 ​ 选择器：指定了受该规则影响的部件； ​ 声明：指定了这个部件上要设置的属性。 ​ Qt样式表中一般不区分大小写，只有类名、对象名和Qt属性名是区分大小写的。一些选择器可以指定相同的声明，使用逗号隔开。样式表的声明部分是一些“属性：值”对组成的列表，它们包含在大括号中，使用分号隔开。 2 选择器类型​ 常用的选择器类型： 选择器 示例 通用选择器 * 类型选择器 QPushButton 属性选择器 QPushButton[flat=“false”] 类选择器 .QPushButton ID选择器 QPushButton#okButton 后代选择器 QDialog QPushButton 孩子选择器 QDialog&gt;QPushButton 3 子控件​ 选择器可以包含子控件来对部件的特定子控件应用规则。 4 伪状态​ 选择器可以包含伪状态来限制规则在部件的指定状态上应用。伪状态出现在选择器之后，用冒号隔离。 ​ 例如鼠标悬停使用hover。伪状态使用感叹号来表示否定，!hover。 ​ 伪状态还可以连用，达到逻辑与的效果。中间使用冒号。 ​ 如果中间使用逗号，则表示逻辑或操作。 ​ 伪状态也可以和子控件联合使用：针对上面3的子控件。 5 冲突解决​ 当几个样式规则对相同的属性指定了不同的值就会产生冲突。 ​ 解决冲突的原则： ​ 1、特殊的选择器优先。 ​ 2、有伪状态比没有伪状态优先。 ​ 3、如果两个选择符的特殊性相同，则后面出现的比前面的优先。 6 继承​ 当使用Qt样式表时，部件并不会自动从父部件继承字体和颜色设置。 7 自定义部件外观​ 当使用样式表时，每一个部件都被看作是拥有4个同心矩形的盒子：内容content、填衬padding、边框border、边距margin。默认除内容外，其他值均为0。 ​ 可以使用： ​ background-image：指定一个背景； ​ background-clip：默认指定背景只能在边框以内的区域进行绘制，通过这个属性可以更改； ​ background-repeat：控制背景图片重复方式； ​ background-origin：控制背景图片原点。 ​ ​ 如果想要背景随着部件的大小变化，自动缩放，那就必须使用border-image。如果同时指定了border-image和background-image，那么border-image就会绘制在background-image上。 ​ 如果图片的尺寸与部件的大小不匹配，它不会拉伸或平铺。图片的对齐方式通过image-position来设置。 ​]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>CSS</tag>
        <tag>QSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QString&QByteArray&QVariant]]></title>
    <url>%2F2019%2F10%2F07%2FQtQString%2F</url>
    <content type="text"><![CDATA[​ QString存储了一串QChar，而QChar提供了一个16位的Unicode 4.0字符。在后台，QString使用隐式共享来减少内存使用和避免不必要的数据复制。 1 隐式共享​ 又称为写时复制。 ​ 使用隐式共享类作为参数传递是既安全又有效的，因为只有一个指向该数据的指针被传递了，只有当函数向它写入时才会复制该数据。 ​ 一个共享类 = 指向一个共享数据块的指针 + 数据组 ​ 共享数据块包含了一个引用计数。每当有新的对象引用了数据块，引用计数就会递增，而对象不再引用数据块就会递减。当引用计数为0 时，共享数据块就会被销毁。当处理共享对象时，有两种复制方法：深复制和浅复制。 ​ 深复制：复制一个对象； ​ 浅复制：复制一个引用（仅仅是一个指向该共享数据块的指针）。 ​ 当隐式共享类使用“=”操作符时就是使用浅复制。但是当一个对象被修改时，就必须进行一次深复制。 ​ 共享的好处是程序不需要进行不必要的数据复制，这样可以减少数据复制、使用更少的内存，对象也可以很容易地被分配，或者作为参数被传递，或者从函数被返回。 ​ Qt中隐式共享类：QByteArray、QCursor、QFont、QPixmap、QString、QUrl、QVariant、所有的容器类等。 2 QByteArray​ 提供一个字节数组，可以用来存储原始字节（包括‘\0’）和传统的以‘\0’结尾的8位字符串。 3 QVariant​ QVariant类像是常见的Qt数据类型的一个共用体，一个QVariant对象在一个时间只保存一个单一类型的单一的值。可以使用toT()(T代表一种数据类型)函数将其转换位T类型，并且获取它的值。]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表]]></title>
    <url>%2F2019%2F10%2F05%2FdatastructureList%2F</url>
    <content type="text"><![CDATA[1 什么是线性表 线性表（List）：多个数据元素的有限序列。 ​ 强调几个关键的地方： ​ 首先，是一个序列； ​ 其次，线性表是有限的。 ​ ​ 在较复杂的线性表中，一个数据元素可以由若干个数据项组成。 ​ 线性表常见的操作： ​ InitList(*L)：初始化操作，建立一个空的线性表L。 ​ ListEmpty(L)：若线性表为空，返回true，否则为false。 ​ ClearList(*L)：将线性表清空。 ​ GetElem(L,i,*e)：将线性表L中的第i个位置元素值返回给e。 ​ LocateElem(L,e)：在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号；否则返回0。 ​ ListInsert(*L,i,e)：在线性表L中的第i个位置插入新元素e。 ​ ListDelete(*L,i,e)：删除线性表L中的第i个位置元素，并用e返回其值。 ​ ListLength(L)：返回线性表L的元素个数。 2 顺序存储结构​ 描述顺序存储结构需要三个属性： 存储空间的起始位置：数组data； 线性表的最大存储容量：数组长度MaxSize； 线性表的当前长度：length。 ​ 【注意】：这里的“数组长度”和“线性表长度”的区别？ ​ 数组长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的。 ​ 线性表的长度是线性表中元素的个数，随着线性表插入和删除的进行，这个量是变化的。 ​ ==随机存储结构== 1234567//顺序存储的结构代码#define MAXSIZE 20 //存储空间初始分配量typedef int ElemType; typedef struct &#123; ElemType data[MAXSIZE];//数组存储数据元素，最大值为MAXSIZE int length; //线性表当前长度&#125;SqList; 2.1 获取元素​ 判断线性表是否为空，确保获取的位置i在数组下标范围内。 12345678910111213//获取元素操作#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Status;//操作结果：用e返回L中第i个数据元素的值Status GetElem(SqList L, int i, ElemType *e) &#123; if (L.length == 0 || i&lt;1 || i&gt;L.length) return ERROR; *e = L.data[i - 1]; return OK;&#125; 2.2 插入操作思路：1）如果插入的位置不合理，则抛出异常； ​ 2）如果线性表长度大于等于数组长度，则抛出异常或动态增加容量； ​ 3）从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置； ​ 4）将要插入元素填入i处； ​ 5）表长加1。 1234567891011121314151617// 插入元素操作Status ListInsert(SqList *L,int i ,ElemType e) &#123; int k; if (L-&gt;length == MAXSIZE)//线性表已满 return ERROR; if (i&lt;1 || i&gt;L-&gt;length+1)//当i不再范围内时 return ERROR; if (i &lt;= L-&gt;length)//插入数据位置不在表尾 &#123; //将要插入位置后数据元素后移一位 for (k = L-&gt;length - 1; k &gt;= i - 1; k--) L-&gt;data[k + 1] = L-&gt;data[k]; &#125; L-&gt;data[i - 1] = e;//新元素插入 L-&gt;length++; return OK;&#125; 2.3 删除操作思路：1）如果删除位置不合理，抛出异常； ​ 2）取出删除元素； ​ 3）从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置； ​ 4）表长减1。 123456789101112131415//删除操作Status ListDelete(SqList *L, int i, ElemType *e) &#123; int k; if (L-&gt;length == 0);//线性表为空 return ERROR; if (i &lt; 1 || i&gt; L-&gt;length + 1)//删除位置不正确 return ERROR; if (i &lt; L-&gt;length) &#123; *e = L-&gt;data[i - 1]; for (k = i; k &lt; L-&gt;length; k++)//将删除位置后继元素前移 L-&gt;data[k - 1] = L-&gt;data[k]; &#125; L-&gt;length--; return OK;&#125; ​ 对于顺序存储结构而言，在存、读数据时，时间复杂度是O(1);而插入或删除时，时间复杂度是O(n)。 3 链式存储结构3.1 顺序存储结构的不足​ 顺序存储结构在插入或删除操作时，需要移动大量的元素，耗时。 3.2 链式存储结构​ 包含数据域和指针域。链表中第一个结点的存储位置叫作头指针。在单链表的第一个结点前附加一个结点，称为头结点。头结点的数据域可以不存任何信息，也可以存线性表长度等公共数据。 12345typedef struct Node &#123; ElemType data;//数据域 struct Node *next;//指针域&#125;Node;typedef struct Node *LinkList; 3.3 单链表读取思路：1）声明一个指针p指向链表的第一个结点，初始化j从1开始； ​ 2）当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1； ​ 3）若到链表末尾p为空，则说明第i个结点不存在； ​ 4）否则查找成功，返回结点p的数据。 12345678910111213141516//获取元素Status GetElem(LinkList L, int i, ElemType *e) &#123; int j; LinkList p; //声明一个指针 p = L-&gt;next; //让p指向链表L的第一个结点 j = 1; //j为计数器 while (p&amp;&amp;j&lt;i)//p不为空且计数器还没有等于i &#123; p = p-&gt;next; //指向下一个结点 ++j; &#125; if (!p || j &gt; i) return ERROR;//第i个结点不存在 *e = p-&gt;data; return OK;&#125; 3.4 单链表插入 链表插入其实就是将待插入位置前一结点的指针域指向新结点，将新结点的指针域指向原来此位置的结点。 思路：1）声明一指针p指向链表头结点，初始化j从1开始； ​ 2）当j&lt;i时，就遍历链表，让 p的指针向后移动，不断指向下一结点，j累加1； ​ 3）若到链表末尾p为空，则说明第i个结点不存在； ​ 4）否则查找成功，在系统中生成一个空结点s； ​ 5）将数据元素e赋值给s-&gt;data; ​ 6）单链表的插入标准语句s-&gt;next=p-&gt;next;p-&gt;next=s； ​ 7）返回成功。 1234567891011121314151617181920//插入元素Status ListInsert(LinkList *L, int i, ElemType e)&#123; int j; LinkList p, s; p = *L; j = 1; while (p&amp;&amp;j &lt; i)//寻找第i-1个结点 &#123; p = p-&gt;next; ++j; &#125; if (!p || j &gt; i)//第i个结点不存在 return ERROR; s = (LinkList)malloc(sizeof(Node));//生成新的结点 s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next = s; return OK;&#125; 3.5 单链表删除 将待删除位置前的结点的指针域指向待删除位置结点后一结点，绕过此位置的结点。 思路：1）声明一指针p指向链表头指针，初始化j从1开始； ​ 2）当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1； ​ 3）若到链表末尾p为空，则说明第i个结点不存在； ​ 4）否则查找成功，将欲删除的结点p-&gt;next赋值给q； ​ 5）单链表的删除标准语句p-&gt;next=q-&gt;next; ​ 6）将q结点中的数据赋值给e，作为返回； ​ 7）释放q结点； ​ 8）返回成功。 1234567891011121314151617181920//删除元素Status ListInsert(LinkList *L, int i, ElemType *e)&#123; int j; LinkList p, q; p = *L; j = 1; while (p-&gt;next&amp;&amp;j &lt; i)//寻找第i-1个结点 &#123; p = p-&gt;next; ++j; &#125; if (!(p-&gt;next) || j &gt; i)//第i个结点不存在 return ERROR; q = p-&gt;next; p-&gt;next = q-&gt;next; *e = q-&gt;data; free (q); return OK;&#125; 3.6 单链表的整表创建​ 创建单链表的过程就是一个动态生成链表的过程。 思路：1）声明一个指针p和计数器j； ​ 2）初始化一空链表L； ​ 3）让L的头结点的指针指向NULL，即建立一个带头结点的单链表； ​ 4）循环： 生成一个新结点赋值给p； 随机生成一数字赋值给p的数据域p-&gt;data; 将p插入到头结点与前一新结点之间。 1234567891011121314//整表创建(头插法)void CreateListHead(LinkList *L, int n) &#123; LinkList p; int i; srand(time(0)); //初始化随机数种子 *L = (LinkList)malloc(sizeof(Node)); (*L)-&gt;next = NULL;//先建立一个带头结点的单链表 for (i = 0; i &lt; n; i++) &#123; p = (LinkList)malloc(sizeof(Node)); p-&gt;data = rand() % 100 + 1; p-&gt;next = (*L)-&gt;next; (*L)-&gt;next = p; &#125;&#125; 123456789101112131415//整表创建(尾插法)void CreateListHead(LinkList *L, int n) &#123; LinkList p,r; int i; srand(time(0)); //初始化随机数种子 *L = (LinkList)malloc(sizeof(Node)); r=*L; //r为指向尾部的结点 for (i = 0; i &lt; n; i++) &#123; p = (LinkList)malloc(sizeof(Node)); p-&gt;data = rand() % 100 + 1; r-&gt;next = p; r=p; &#125; r-&gt;next=NULL;&#125; 3.7 单链表的整表删除思路：1）声明一结点p和q； ​ 2）将第一个结点赋值给p； ​ 3）循环： - 将下一结点赋值给q； - 释放p； - 将q赋值给p； 1234567891011121314//整表删除Status ClearList(LinkList *L)&#123; LinkList p, q; p = (*L)-&gt;next; while (p) &#123; q = p-&gt;next; free(p); p = q; &#125; (*L)-&gt;next = NULL; return OK;&#125; 4 静态链表 用数组描述的链表，就叫静态链表，也称为游标实现法。 ​ 对数组第一个和最后一个元素作为特殊元素处理，不存数据。通常把未被使用的数组元素称为备用链表，即空着的位置数组元素。数组第一个元素的cur（游标）存放备用链表的第一个结点的下标，数组的最后一个元素存放第一个有数值的元素的下标。 5 循环链表 将单链表中终端结点的指针端改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表。 ​ 其实循环链表和单链表的主要差异就体现在循环的判断条件上，原来是判断指针与是否为空，现在是判断是否为头结点。 ​ 不过我们这里可以改进以下循环链表，使用尾指针代替头指针，这样对于查找开始结点和终端结点都很方便了。 6 双向链表 &gt;双向链表：在单链表的每个结点中，再设置一个指向其前驱结点的指针域。 ​ 这里插入操作时，顺序很重要。 ​ $p\rightarrow q$，现在要在p和q之间，插入s结点； ​ $p\rightarrow s\rightarrow q$ 12345s-&gt;prior=p;s-&gt;next=p-&gt;next;p-&gt;next-&gt;prior=s;p-&gt;next=s;//注意这里结点之间都是双向的。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习—降维]]></title>
    <url>%2F2019%2F10%2F04%2FPCA%2F</url>
    <content type="text"><![CDATA[为什么需要降维？​ （1）多余的特征会影响或误导学习器 ​ （2）更多特征意味着更多参数需要调整，过拟合风险也越大 ​ （3）数据的维度可能只是虚高，真实维度可能比较小 ​ （4）维度越少意味着训练越快，更多东西可以尝试，能够得到更好的结果 ​ （5）如果我们想要可视化数据，就必须限制在两个或三个维度上 ​ 因此，我们需要通过降维把无关或冗余的特征删掉。 ​ 降维的方法主要有： 1234567891011121314151617graph LRA[降维] --&gt;| | B[特征提取]B[特征提取] --&gt;| | 1[线性降维]B[特征提取] --&gt;| | 2[流形学习-非线性降维]B[特征提取] --&gt;| | 3[奇异值分解SVD]1[线性降维] --&gt;| | 11[主成分分析]1[线性降维] --&gt;| | 12[因子分析]1[线性降维] --&gt;| | 13[独立成分分析]1[线性降维] --&gt;| | 14[线性判别分析]A[降维] --&gt;| | C[特征筛选]C[特征筛选] --&gt;| | D[缺失值比率]C[特征筛选] --&gt;| | E[低方差滤波]C[特征筛选] --&gt;| | F[高相关滤波]C[特征筛选] --&gt;| | G[随机森林]C[特征筛选] --&gt;| | H[反向特征消除]C[特征筛选] --&gt;| | J[前向特征选择] ​ 低方差滤波：方差很小，包含的信息量很少； ​ 高相关滤波：比如两个特征相关性较大，一个特征基本上可以替代另一个特征，就可以只保留一个； ​ 随机森林：可以返回特征的重要性； ​ 反向特征消除：把数据放到模型里面训练，剃掉一个特征来看看，模型的改变会不会很大； ​ 前向特征选择：选一个最重要的特征放到模型里面，然后加一个重要的特征，观察模型改变； 维度诅咒​ 当训练实例拥有几千个甚至上百万个特征时，不仅导致训练非常缓慢，也更加难找到好的解决方案，这个问题就是维度诅咒。 ​ 在现实中，我们一般可以大量减少特征的数量，其一是有些特征对于分类任务来说是无足轻重的，比如，MNIST图像中边框的白色区域像素位，另外两个相邻像素通常是高度相关的，如果将它们合成为一个像素，也不会丢失太多的信息。 ​ 两种主要的数据降维方法：投影，流形学习； ​ 三种降维技术：PCA，Kernal PCA ，LLE。 ​ ​ 高纬度数据集很大可能是非常稀疏的：大多数训练实例可能彼此之间相聚较远。训练集的维度越高，过度拟合的风险就越大。理论上来说，通过增大训练集，使训练实例达到足够的密度，是可以解开维度的诅咒的。但是，实践中，要达到给定密度所需要的训练实例数量随着维度增加呈指数式上升。 数据降维的主要方法投影​ 实际中，训练实例在所有维度上并不是均匀分布的，许多特征几乎是不变的，有些特征是高度相关的。因此，高维空间的所有训练实例实际上（或近似）受一个低得多的低维子空间的影响。 ​ 在许多情况下，子空间可能会弯曲或转动。 流形学习​ d维流形学习就是n（其中，d&lt;n）维空间中的一部分，局部类似于一个d维超平面。 ​ 降维算法—PCA​ 主成分分析法，是一种非监督的机器学习算法，主要用于数据的降维。通过降维，可以发现更便于人类理解的特征，其他也可以用于：可视化，去噪。 ​ PCA是通过抛弃携带信息量较少的纬度，保留主要的特征信息来对数据进行降维处理，思路上是使用少数几个有代表性、互不相关特征来代替原先的大量的、存在一定相关性的特征，从而加速机器学习进程。白化的目的是去掉数据之间的相关联度和令方差归一化。【数据预处理方式（去均值、归一化、PCA降维）https://blog.csdn.net/maqunfi/article/details/82252480】 什么是PCA​ 对于一个有两个特征的数据集，如果我们用x轴表示特征1，y轴表示特征2，那么结果如下：]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>PCA</tag>
        <tag>降维</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习—Kmeans聚类]]></title>
    <url>%2F2019%2F10%2F03%2FKmeans%E8%81%9A%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[​ 聚类算法是一种典型的无监督算法，目的是依据已知数据，将相似度高的样本集中到各自的簇中。 ​ 聚类算法可以实现数据分割，异常点的监控。所谓的异常点就是远离簇的样本，而这些样本可能就是某些场景下的关注点。 ​ 聚类算法种类有：Kmeans聚类、K中心聚类、谱系聚类、EM聚类算法、基于密度的聚类和基于网格的聚类等。 ​ 本文主要是Kmeans聚类，该算法利用距离远近的思想将目标数据聚为指定的k个簇，簇内样本越相似，表明聚类效果越好。簇中心点由各簇样本均值计算得到。 Kmeans的思想​ 该算法思路很简单，就是不断计算各样本点与簇中心之间的距离，直到所有簇内样本的离差平方和之和达到最小为止。具体步骤如下： ​ 1）从数据中随机挑选k个样本点作为原始的簇中心； ​ 2）计算剩余样本与簇中心的距离，并把各样本标记为离k个簇中心最近的类别； ​ 3）重新计算各簇内样本点的均值，并以均值作为新的k个簇中心； ​ 4）不断重复2）和3），直到簇的中心的变化趋于稳定，形成最终的k个簇。 Kmeans的原理​ 根据如上思想，可以将目标函数表示为： J(c_1,c_2,...c_k)=\sum_{j=1}^{k}\sum_{i}^{n_j}(x_i-c_j)^2​ 其中， ​ $c_j$表示第$j$个簇的簇中心， ​ $x_i$属于第$j$个簇的样本$i$， ​ $n_j$表示第$j$个簇的样本总量。 ​ 即，在第$j$个簇内，计算其他样本点到簇中心的距离平方，然后将所有的距离平方累加求和（内层求和号），此时一个簇计算得到的是一个距离和值，最后将所有簇（$j$个簇）的距离和值再次累加求和（外层求和号），就是所有簇内样本的离差平方和之和。 ​ 对于上述目标函数，未知数是$c_j$，要想求目标函数的最小值，得先确定$c_j$的值。刚好目标函数是一个凸函数，可以通过求导的方式获取$c_j$的值。 ​ 第一步，对目标函数求偏导 \frac {\partial J}{\partial c_j}=\sum_{i=1}^{n_j}-2(x_i-c_j)​ 【注意】：由于这里仅对第$j$个簇中心求偏导，所以其他簇此时的偏导数均为0。 ​ 第二步，令导数为0 \sum_{i=1}^{n_j}-2(x_i-c_j)=0 \\ n_jc_j-\sum_{i=1}^{n_j}x_i=0 \\ c_j= \frac {\sum_{i=1}^{n_j}x_i}{n_j}=\mu_j​ 由此看出，只有当簇中心$c_j$为簇内样本的均值时，目标函数才会达到最小。这也是上面为什么用均值作为簇中心。 K值确定​ 前面都是基于已知的k个簇运算出最佳的簇中心，如果聚类之前不知道该聚为几类，该如何确定最佳的k值呢？ ​ 常用的有三种方式：簇内离差平方和拐点法、轮廓系数法、间隔统计量法。 拐点法​ 拐点法比较简单，类似于PCA降维时通过绘制贡献率曲线决定维数。通过可视化方法找到”拐点“对应的k值。 123456789101112131415161718192021222324252627# 导入第三方包import pandas as pdimport numpy as np import matplotlib.pyplot as pltfrom sklearn.cluster import KMeansfrom sklearn import metrics# 随机生成三组二元正态分布随机数 np.random.seed(1234)mean1 = [0.5, 0.5]cov1 = [[0.3, 0], [0, 0.3]]x1, y1 = np.random.multivariate_normal(mean1, cov1, 1000).Tmean2 = [0, 8]cov2 = [[1.5, 0], [0, 1]]x2, y2 = np.random.multivariate_normal(mean2, cov2, 1000).Tmean3 = [8, 4]cov3 = [[1.5, 0], [0, 1]]x3, y3 = np.random.multivariate_normal(mean3, cov3, 1000).T# 绘制三组数据的散点图plt.scatter(x1,y1)plt.scatter(x2,y2)plt.scatter(x3,y3)# 显示图形plt.show() 12345678910111213141516171819202122232425262728293031323334353637# 构造自定义函数，用于绘制不同k值和对应总的簇内离差平方和的折线图def k_SSE(X, clusters): # 选择连续的K种不同的值 K = range(1,clusters+1) # 构建空列表用于存储总的簇内离差平方和 TSSE = [] for k in K: # 用于存储各个簇内离差平方和 SSE = [] kmeans = KMeans(n_clusters=k) kmeans.fit(X) # 返回簇标签 labels = kmeans.labels_ # 返回簇中心 centers = kmeans.cluster_centers_ # 计算各簇样本的离差平方和，并保存到列表中 for label in set(labels): SSE.append(np.sum((X.loc[labels == label,]-centers[label,:])**2)) # 计算总的簇内离差平方和 TSSE.append(np.sum(SSE)) # 中文和负号的正常显示 plt.rcParams['font.sans-serif'] = ['Microsoft YaHei'] plt.rcParams['axes.unicode_minus'] = False # 设置绘图风格 plt.style.use('ggplot') # 绘制K的个数与GSSE的关系 plt.plot(K, TSSE, 'b*-') plt.xlabel('簇的个数') plt.ylabel('簇内离差平方和之和') # 显示图形 plt.show()# 将三组数据集汇总到数据框中X = pd.DataFrame(np.concatenate([np.array([x1,y1]),np.array([x2,y2]),np.array([x3,y3])], axis = 1).T)# 自定义函数的调用k_SSE(X, 15) 轮廓系数法​ 该方法综合考虑了簇的密集性与分散性两个信息，即数据集被划分为k个簇，簇内高密集，簇间高分散。轮廓系数的计算方式： S(i)=\frac {b(i)-a(i)}{max(a(i),b(i))}​ 其中，$a(i)$——簇内的密集性，代表样本i与同簇内其他样本点距离的平均值； ​ $b(i)$——簇间的分散性，计算过程，样本i与其他非同簇样本点距离的平均值，然后从平均值中挑选出最小值。 ​ 当$S(i)$接近于-1，说明样本分配的不合理，需要将其分配到其他簇； ​ 当$S(i)$近似为0，说明样本处于模糊地带，即簇的边界； ​ 当$S(i)$近似为1，说明样本i分配的合理。 ​ 可以看出$S(i)$仅仅是计算单个样本i的轮廓系数，最后需要对所有点的轮廓系数求均值，才是对应k个簇的总轮廓系数。 ​ 当总轮廓系数小于0时，说明聚类效果不佳； ​ 当总轮廓系数接近于1时，说明簇内样本的平均距离a非常小，簇间距离b非常大，聚类合理。 ​ sklearn中对应模块：metrices中的silhouette_score。 1234567891011121314151617181920212223242526# 构造自定义函数，用于绘制不同k值和对应轮廓系数的折线图def k_silhouette(X, clusters): K = range(2,clusters+1) # 构建空列表，用于存储个中簇数下的轮廓系数 S = [] for k in K: kmeans = KMeans(n_clusters=k) kmeans.fit(X) labels = kmeans.labels_ # 调用字模块metrics中的silhouette_score函数，计算轮廓系数 S.append(metrics.silhouette_score(X, labels, metric='euclidean')) # 中文和负号的正常显示 plt.rcParams['font.sans-serif'] = ['Microsoft YaHei'] plt.rcParams['axes.unicode_minus'] = False # 设置绘图风格 plt.style.use('ggplot') # 绘制K的个数与轮廓系数的关系 plt.plot(K, S, 'b*-') plt.xlabel('簇的个数') plt.ylabel('轮廓系数') # 显示图形 plt.show() # 自定义函数的调用k_silhouette(X, 15) 间隔统计量法​ 该方法适用于任何聚类算法。 ​ Gap Statistic方法就是通过比较参照数据集的期望和实际数据集的对数，找到其下降最快的k值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# 自定义函数，计算簇内任意两样本之间的欧氏距离def short_pair_wise_D(each_cluster): mu = each_cluster.mean(axis = 0) Dk = sum(sum((each_cluster - mu)**2)) * 2.0 * each_cluster.shape[0] return Dk# 计算簇内的Wk值def compute_Wk(data, classfication_result): Wk = 0 label_set = set(classfication_result) for label in label_set: each_cluster = data[classfication_result == label, :] Wk = Wk + short_pair_wise_D(each_cluster)/(2.0*each_cluster.shape[0]) return Wk# 计算GAP统计量 def gap_statistic(X, B=10, K=range(1,11), N_init = 10): # 将输入数据集转换为数组 X = np.array(X) # 生成B组参照数据 shape = X.shape tops = X.max(axis=0) bots = X.min(axis=0) dists = np.matrix(np.diag(tops-bots)) rands = np.random.random_sample(size=(B,shape[0],shape[1])) for i in range(B): rands[i,:,:] = rands[i,:,:]*dists+bots # 自定义0元素的数组，用于存储gaps、Wks和Wkbs gaps = np.zeros(len(K)) Wks = np.zeros(len(K)) Wkbs = np.zeros((len(K),B)) # 循环不同的k值， for idxk, k in enumerate(K): k_means = KMeans(n_clusters=k) k_means.fit(X) classfication_result = k_means.labels_ # 将所有簇内的Wk存储起来 Wks[idxk] = compute_Wk(X,classfication_result) # 通过循环，计算每一个参照数据集下的各簇Wk值 for i in range(B): Xb = rands[i,:,:] k_means.fit(Xb) classfication_result_b = k_means.labels_ Wkbs[idxk,i] = compute_Wk(Xb,classfication_result_b) # 计算gaps、sd_ks、sk和gapDiff gaps = (np.log(Wkbs)).mean(axis = 1) - np.log(Wks) sd_ks = np.std(np.log(Wkbs), axis=1) sk = sd_ks*np.sqrt(1+1.0/B) # 用于判别最佳k的标准，当gapDiff首次为正时，对应的k即为目标值 gapDiff = gaps[:-1] - gaps[1:] + sk[1:] # 中文和负号的正常显示 plt.rcParams['font.sans-serif'] = ['Microsoft YaHei'] plt.rcParams['axes.unicode_minus'] = False # 设置绘图风格 plt.style.use('ggplot') # 绘制gapDiff的条形图 plt.bar(np.arange(len(gapDiff))+1, gapDiff, color = 'steelblue') plt.xlabel('簇的个数') plt.ylabel('k的选择标准') plt.show() # 自定义函数的调用gap_statistic(X) ​ 上述三种方法判断合理的k值方法为： ​ 拐点法：找到斜率变化最大的那个k； ​ 轮廓系数法：找到曲线最高、最接近1的k； ​ 间隔统计量法：找到gapdiff首次出现正值的k。 Kmeans聚类的注意点​ 在做Kmeans聚类时注意： ​ 1）聚类前必须指定具体的簇数k值； ​ 2）对原始数据集做必要的标准化处理，如果原始数据集在量纲上存在差异，就必须标准化，否则不需要； ​ 3）如果数据集中有离散型的字符型变量，需要对该变量做预处理，比如设置哑变量或转换成数值化的因子。 ​ 可以借助seaborn的lmplot方法绘制聚类效果的散点图；为了直观对比k个簇内样本之间的差异，可以使用雷达图对各个维度的信息进行展现。雷达图的绘制需要pygal模块，调用Radar类。 手动实现Kmeans聚类算法构建距离计算函数1234#样本点和簇中心的距离计算def distEclud(arrA,arrB): dist=np.sum(np.power(arrA-arrB,2),axis=1)#这里用平方和代替距离，简化计算 return dist 随机初始簇心1234567#生成随机簇中心def randCent(dataSet,k): n=dataSet.shape[1]#获取数据集的特征数 data_min=dataSet.iloc[:,:].min()#获取每一列特征的最小值 data_max=dataSer.iloc[:,:].max()#获取每一列特征的最大值 data_cent=np.random.uniform(data_min,data_max,(k,n))#生成取值范围内的随机数，k行n列，即初始簇中心 return data_cent Kmeans聚类算法​ 在执行Kmeans聚类算法时，需要不断地迭代质心，因此需要两个可迭代容器来完成该目标。 ​ 第一个容器用于存放和更新质心，该容器可考虑使用list来执行，list不仅是可迭代对象，同时list内不同元素索引位置也可用于标记和区分各质心，即各簇的编号； ​ 第二个容器则需要记录、保存和更新各点到质心之间的距离，并能够方便对其进行比较，该容器由有3列的数组来执行。 ​ 第一列用于存放最近一次计算完成后某点到各质心的最短距离； ​ 第二列用于计算完成后根据最短距离得到的代表对应质心的数值索引，即所属簇，即质心的编号； ​ 第三列用于存放上一次对应的质心编号； ​ 后两列用于比较质心发生变化后某点所属簇的情况是否发生变化。 123456789101112131415161718192021222324#Kmeans聚类算法def KMeans(dataSet,k,distMeas=distEclud,createCent=randCent): m,n=dataSet.shape centroids=createCent(dataSet,k)#生成k个质心 clusterAssment=np.zeros((m,3))#容器2 clusterAssment[:,0]=np.inf#存放无穷大值 clusterAssment[:,1:3]=-1#存放-1作为初始值 #连接原始数据集和容器2 result_set=pd.concat([dataSet,pd.DataFrame(clusterAssment)],axis=1,ignore_index=True) clusterChanged=True while clusterChanged: clusterChanged=False for i in range(m): dist=distMeas(dataSet.iloc[i,:].values,centroids)#计算样本点与所有初始质心的距离 result_set.iloc[i,n]=dist.min()#获取与所有质心的距离中最小的一个 #获取最小距离的索引,其实此时的索引就是特征索引值 result_set.iloc[i,n+1]=np.where(dist==dist.min())[0] #只有当所有质心都与上次相同 clusterChanged=not (result_set.iloc[:,-1]==result_set.iloc[:,-2]).all() if clusterChanged: cent_df=result_set.grouby(n+1).mean()#各个簇分组统计均值 centroids=cen_df.iloc[:,:n].values#用簇中所有点的均值作为质心 result_set.iloc[:,-1]=result_set.iloc[:,-2]#将索引更新 return centroids,result_set ​ 在聚类结束之后，可以查看最后一列查看分类情况，如：result.iloc[:,-1].value_counts()。 ​ 误差平方和​ 误差平方和（SSE）是聚类算法模型最重要评估指标。 ​ 对于聚类算法而言，误差平方和仍然有一定的局限性，主要体现在以下几点： 对于任意数据集而言，聚类误差平方和和质心数量高度相关，随着质心增加，误差平方和将逐渐下降； 误差平方和还与数据集本身数据量大小、量纲大小、数据维度高度相关，数据量越大、量纲越大、维度越高则在相同质心数量情况下误差平方和也将更大。 ​ 增加簇的个数肯定可以降低SSE值，但这违背了聚类的目标，即在保持簇的数据不变的情况下，提高簇的质量。 ​ 因此，模型误差平方和没有绝对意义，比较不同数据集聚类结果的误差平方和没有任何意义，误差平方和在聚类分析中主要作用有以下两点： 确定模型最优化目标，结合距离计算方法进而推导质心选取方法； 对于确定数据集可绘制横轴为质心数量、纵轴为误差平方和的曲线，可以判断，曲线整体将呈现下降趋势，其实就是上面所说的”拐点法”。 ​ 使用后处理来提高聚类性能​ 对生成的簇进行后处理，一种方法是将最大的SSE值的簇划分为两个簇。具体实现时可以将最大簇包含的点过滤出来并在这些点上运行Kmeans聚类算法，k设为2。 ​ 由于为了保持簇的总数不变，上面拆分变成两个簇，就需要将某两个簇合并成一个簇，有两种可以量化的方法：合并最近的质心，或者合并两个是的SSE增幅最小的质心。 通过计算所有质心之间的距离，然后合并距离最近的两个点来实现。 合并两个簇然后计算总的SSE值。 ​ 必须在所有可能的两个簇上重复上述处理的过程，直到找到合并最佳的两个簇为止。这就是后面即将提到的“二分 Kmeans算法”。 存在的问题​ 随机初始质心对最终的聚类结果是有影响的，所以尽量降低初始化质心的随机性对最后聚类结果造成影响，方案有以下几种： ​ 1）在初始化质心随机生成的过程中，尽可能的让质心更加分散 ​ 这点其实在利用np.random.random进行[0,1)区间取均匀分布抽样而不是进行随机抽样。 ​ 2）人工制定初始质心 ​ 即在观察数据集分布情况后，手工设置初始质心，此举也能降低随机性影响。 ​ 3）增量的更新质心 ​ 二分Kmeans算法​ 为克服Kmeans算法收敛于局部最小值的问题，提出二分Kmeans算法，该算法的思路是，首先将所有点看作一个簇，然后一分为二。之后选择其中一个簇继续进行划分，选择哪一个簇进行划分取决于对其划分是否可以最大程度降低SSE值，直到得到用户指定的簇数目为止。 ​ 另一种做法是选择SSE最大的簇进行划分，直到簇数据达到k为止。 ​ ​ 相关阅读​ （1）机器学习sklearn19.0聚类算法——Kmeans算法 ​ （2）从零开始学Python数据分析与挖掘 ​ （3）机器学习实战 ​ （4）菊安酱的机器学习 第9期 Kmeans聚类]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>聚类</tag>
        <tag>KMeans</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[弄清相对路径]]></title>
    <url>%2F2019%2F10%2F02%2F%E5%BC%84%E6%B8%85%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[路径问题​ 一般我们在进行数据挖掘之前，需要先将数据集从文件中读取到例如pandas的DataFrame数据框中，那么需要指定路径。所以理清一下路径表示的问题。 ​ 路径表示分为绝对路径和相对路径。 ​ 绝对路径：即文件在本地磁盘上的真正路径； ​ 相对路径：即相对于当前文件的路径。通俗点说，就是你要读取文件的位置相对于正在执行的程序文件所处位置的路径。 ​ 比较而言，绝对路径毫无灵活性，在不同计算机上执行程序就必须重新指定路径；相对路径只需要将文件放在相应的位置，程序不需要修改就能执行。【注意：由于系统的原因，可能有“/”和“\”的区别，所以一般加上r即可。】 ​ 相对路径./和../的区别​ ./：表示目前所在路径； ​ ../：表示上一层路径； ​ /：代码根目录。 ​ 举个栗子： ​ 下面这段代码是要读取一个数据集： 1iris=pd.read_csv('./datas/iris.csv') ​ 这里的程序执行文件是Kmeans.ipynb，数据在datas文件夹中； ​ 因为此时程序文件Kmeans.ipynb和datas文件夹是同级的，所以就是在当前路径下索引即可。 ​ 如果说datas文件夹在上一级文件，那么就需要使用../。 ​ 相当于以Kmeans.ipynb文件为基点，跳到要找的文件，如果需要返回上级文件夹，就需要使用一次../；否则用./就可以了。 ​ 如果还不是很明白，可以看看下面的两篇博客，比较容易理解。 参考资料​ 秒懂文件路径/ 和 ./ 和 ../ 和 ../../ ​ 相对路径./与../区别 ​ 如有疑问或文中有不妥之处，可以留言交流！]]></content>
      <categories>
        <category>细节</category>
      </categories>
      <tags>
        <tag>路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[70周年]]></title>
    <url>%2F2019%2F10%2F01%2F70%E5%91%A8%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[KMP算法]]></title>
    <url>%2F2019%2F09%2F30%2FKMP%2F</url>
    <content type="text"><![CDATA[学习到串这一章，碰到一个不太好理解的算法，记录一下。 数据结构：串； 字串的定位操作通常称为串的模式匹配，算是串中最重要的操作之一。这里主要讲一下KMP模式匹配算法（即克努特-莫里斯-普拉特算法）。 1、前缀值求解在进行KMP算法操作之前需要求解将要匹配的字符串的前缀值，表现为一个前缀数组。（有些书中称为next数组）第一步，前缀表下面是即将要匹配的字符串，先写出前缀表：第二步，求出前缀值把每个前缀当成独立的字符串，找出最长的公共的前后缀，并且这个前后缀是比原始字符串要短；然后，将最后一行删除，因为最后的字符串就是其本身，同时在最前面添加一个-1。这样就构成了前缀数组：-1，0，0，1，2； 进行匹配当出现匹配失败时（如上图），查找失配位置的前缀值，比如上图匹配a和b失败，当前的前缀值是1（即图中红色的圆圈处），所以转到匹配字符串下标为1的位置（即图中绿色的圆圈处）。此时，将P串后移，使得红叉和绿圈对齐，从这里继续开始匹配。绿圈之前的字符不再需要匹配，因为前面一定是匹配的，不需要验证了。（这就是KMP算法相对于朴素匹配算法的优势）第三步，前缀实现下图是前缀值求解的算法图解：在上图中，下标为6的位置的前缀值怎么求解？ 通过观察6位置之前的字符串，发现5处的前缀值为1，要使6处的前缀值为2，只有其位置的字符为B。所以，需要做的就是检查一下，6处的字符是不是B。len——字符串达到的最大的长度；其实现为： 1234567891011121314151617181920212223// 前缀实现void prefix_table(char pattern[], int prefix[], int n) &#123; prefix[0] = 0; int len = 0; int i = 1; while (i &lt; n) &#123; if (pattern[i] == pattern[len]) &#123; len++; prefix[i] = len; i++; &#125; else &#123; if (len &gt; 0) &#123; len = prefix[len - 1]; &#125; else &#123; prefix[i] = len; i++; &#125; &#125; &#125;&#125; 12345678910// 将前缀数组后后移一位，方便后面KMP算法计算void move_prefix_table(int prefix[], int n)&#123; int i; for (i = n - 1; i &gt; 0; i--) &#123; prefix[i] = prefix[i - 1]; &#125; prefix[0] = -1;&#125; 2、KMP实现1234567891011121314151617181920212223242526272829void kmp_search(char text[], char pattern[])&#123; int n = strlen(pattern); //计算字符串长度 int * prefix = malloc(sizeof(int) * n);//内存分配 prefix_table(pattern, prefix, n);//前缀表求解 move_prefix_table(prefix, n);//前缀表移位 //text[i] ,len(text) =m; //pattern[j],len(pattrn) =n; while (i &lt; m) &#123; if (j == n - 1 &amp;&amp; text[i] == pattern[j]) &#123; printf("Found pattern at %d\n", i - j); j = prefix[j]; &#125; if (text[i] == pattern[j]) &#123; i++; j++; &#125; else &#123; j = prefix[j]; if (j == -1) &#123; i++; j++; &#125; &#125; &#125;&#125; 3、参考视频：https://www.bilibili.com/video/av11866460/?spm_id_from=333.788.videocard.0书籍：大话数据结构]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>KMP</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-线性回归]]></title>
    <url>%2F2019%2F09%2F30%2FLineRegression%2F</url>
    <content type="text"><![CDATA[​ 线性回归——一种有监督的学习算法，即在建模过程中必须同时具备自变量x和因变量y。更为概括地说，线性模型就是对输入特征加权求和，再加上一个我们称为偏置项的常数。 ​ 两种不同的训练模型的方法： 通过“闭式”方程——直接计算出最适合训练集的模型参数（也就是使训练集上的成本函数最小化的模型参数）。 使用迭代优化的方法，即梯度下降法（GD）。逐渐调整模型参数直至训练集上的成本函数调至最低。包括梯度下降的几种变体：批量梯度下降、小批量梯度下降、随机梯度下降。 ​ 一元线性回归定义​ 又称为简单线性回归模型，是指模型中只有一个自变量和一个因变量，给模型的数学表达式可以表示成： y=ax+b+\xi​ 类似于一次函数，其中$\xi$为模型的误差，$a$和$b$统称为回归系数。误差项$\xi$的存在主要是为了平衡等号两边的值，通常被称为模型无法解释的部分。如下图： 确定目标函数​ 我们希望预测值和实际值的差距尽量小，那么如何表示该差距呢？ ​ 由于误差项$\xi$是y与ax+b的差，结果可能是正值或负值，因此误差项$\xi$达到最小的问题需转换为误差平方和最小的问题（最小二乘法的思路）。 J(a,b)=\sum^{n} _{i=1} {\xi^2}=\sum^{n}_{i=1}{(y_i-ax_i-b)^2}​ 上面的函数可以称为损失函数（loss function)或效用函数（utility function）。通过分析问题，确定问题的损失函数或者效用函数；通过最优化损失函数或者效用函数，获得机器学习的模型。 ​ 求解误差项最小就是求解$J(a,b)$的最小值。该目标函数其实就是一个二元二次函数，可以使用偏导数的方法求解出a和b，进而得到目标函数的最小值。（这里可能你会有疑问：为什么求出a和b，就能得到目标函数的最小值？——这是因为这里我们已知x和y，自变量其实是a和b，J是因变量，所以要求J的最小值，自然需要对a和b求偏导。对于损失函数、代价函数、目标函数的理解参见博客：理解代价函数）推到过程如下图： Python计算得到模型的回归参数，有第三方模块statsmodels，它是专门用于统计建模的第三方模块，可以调用子模块中的ols函数计算a和b。 ​ 简单线性回归的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344import numpy as npclass SimpleLinearRegression1: def __init__(self): """初始化Simple Linear Regression 模型""" self.a_=None self.b_=None def fit(self,x_train,y_train): """根据训练数据集x_train,y_train训练Simple Linear Regression 模型""" assert x_train.ndim==1,\ "Simple Linear Regressor can only solve single feature training data" assert len(x_train)==len(y_train),\ "the size of x_train must be equal to the size of y_train" x_mean=np.mean(x_train)#计算均值 y_mean=np.mean(y_train)#计算均值 num=0.0 d=0.0 for x_i,y_i in zip(x_train,y_train): num+=(x_i-x_mean)*(y_i-y_mean)#计算a的分子 d+=(x_i-x_mean)**2#计算a的分母 self.a_=num/d#得到a self.b_=y_mean-self.a_*x_mean#得到b def predict(self,x_predict): """给定待预测数据集x_predict,返回表示x_predict的结果向量""" assert x_predict.ndim==1,\ "Simple Linear Regressor can only solve single feature training data" assert self.a_ is not None and self.b_ is not None,\ "must fit before predict!" return np.array([self._predict(x) for x in x_predict]) def _predict(self,x_signle): """给定单个待预测数据x_signle,返回x_signle的预测结果值""" return self.a_*x_signle+self.b_#根据上面计算的a和b，构建线性模型 def __repr__(self): return "SimpleLinearRegression1()" 向量化​ 从上面的简单线性回归实现中，我们可以看到，对于回归系数的计算，我们是通过for循环+数学公式计算得到的，在这里我再次贴出那段实现代码： 1234#for循环计算for x_i,y_i in zip(x_train,y_train): num+=(x_i-x_mean)*(y_i-y_mean)#计算a的分子 d+=(x_i-x_mean)**2#计算a的分母 ​ 如果数据量比较大，那么这个过程是很缓慢的，所以需要优化。 ​ 首先，从数学表达式上来看， ​ a的分子和分母都可以用下面的向量的点乘表示。向量的运算速度高于for循环。 ​ 通过numpy的向量运算可以提高性能。那么我们将上面的for循环的代码修改一下： 12num=(x_i-x_mean).dot(y_i-y_mean)d=(x_i-x_mean).dot(x_i-x_mean) #### 多元线性回归 ##### 定义 ​ 上面讨论的是一元线性回归模型，相对来说比较简单。实际上，我们的数据集的属性（即自变量）不止一个。对于含有多个属性的数据构建线性回归模型就是多元线性回归模型。如下图： ​ 从上图可以看出，X是一组向量，具有多个特征。 ​ **线性回归模型预测**： $$ \hat y^{(i)}=\theta_0+\theta_1X_1^{(1)}+\theta_2X_2^{(2)}+…\theta_nX_n^{(n)} $$ ​ **线性回归模型预测（向量化）**： $$ \hat y=X_b\cdot {\theta} $$ ​ ##### 目标函数 ​ 对于多元线性回归模型，目标函数和一元线性回归模型基本一致： ​ 上面我们添加X_0参数，使其恒等于1，这样我们就可以使用向量的方式表示预测模型了。 ​ 所以，目标函数的求解变成了： ​ 闭式解法——就是一个直接得出结果的数学方程（即多元线性回归的正规方程解）： \theta =(X_b^TX_b)^{-1}X_b^Ty​ 求解出来的$\theta$如下： 多元线性回归的实现123456789101112131415161718192021222324252627282930313233343536373839404142import numpy as np#from .metrics import r2_scoreclass LinearRegression: def __init__(self): """"初始化Linear Regression模型""" self.coef_=None self.interception_=None self._theta=None def fit_normal(self,X_train,y_train): """"根据训练数据集X_train,y_train训练Linear Regression模型""" assert X_train.shape[0]==y_train.shape[0],\ "the size of X_train must be equal to the size of y_train" X_b=np.hstack([np.ones((len(X_train),1)),X_train]) self._theta=np.linalg.inv(X_b.T.dot(X_b)).dot(X_b.T).dot(y_train) self.interception_=self._theta[0] self.coef_=self._theta[1:] return self def predict(self,X_predict): """给定待预测数据集X_predict，返回表示X——predict的结果向量""" assert self.interception_ is not None and self.coef_ is not None,\ "must fit before predict!" assert X_predict.shape[1]==len(self.coef_),\ "the feature number of X_predict must be equal to X_train" X_b = np.hstack([np.ones((len(X_predict), 1)), X_predict]) return X_b.dot(self._theta) def score(self,X_test,y_test): """根据测试数据集X_test和y_test确定当前模型的准确度""" y_predict=self.predict(X_test) #return r2_score(y_test,y_predict) def __repr__(self): return "LinearRegression()" 计算复杂度​ 标准方程求逆的矩阵$X^T\cdot X$，是一个$n*n$的矩阵（n是特征数量）。对这种矩阵求逆的计算复杂度通常为$O(n^{2.4})到O(n^{3})$之间（取决于实现）。因此当特征数量特别大时，标准方程的计算是很缓慢的。好的一面，线性模型一经训练完成，预测就非常迅速。 多项式回归定义​ 其实可以用线性模型拟合非线性数据。一个简单的方法就是将每个特征的幂次方添加为一个新特征，然后在这个拓展过的特征集上训练线性模型。这种方法被称为多项式回归。 ​ 将$X^2$和$X$分别看作两个特征，那么这个多项式回归依然可以看成线性回归。只不过对于x来说，是一个2次方程。 ​ 【注意】：当存在多个特征时，多项式回归能够发现特征和特征之间的关系（纯线性模型做不到这一点）。这是因为PolynomialFeatures会在给定的多项式阶数下，添加所有特征组合。如下： ​ 要小心特征组合的数量爆炸！！！ ##### 验证数据集与交叉验证 ​ 测试数据集不参与模型的创建。 ​ 仍然存在一个问题：**随机**？ ​ 由于我们的验证数据集都是随机的从数据集中切出来的，那么训练出来的模型可能对于这份验证数据集过拟合，但是我们只有这一份数据集，一旦这个数据集中相应的有比较极端的数据，就可能导致这个模型不准确。于是就有了**交叉验证**。 过拟合和欠拟合 ​ 我们由已知的训练数据得到的曲线，在面对新的数据的能力非常弱，即**泛化能力差**。例如，我们在训练数据集上模型的准确率很好，但是在测试数据集上模型准确率却很差。 ​ 因此，我们需要寻找泛化能力最好的地方。 ​ ​ 使用交叉验证来评估模型的泛化性能，如果模型在训练集上表现良好，但是交叉验证的泛化表现非常糟糕，那么模型就是**过拟合**。如果在二者上的表现都不佳，那就是**欠拟合**。这就是判读模型太简单还是太复杂的一种方法。如下图：分别是欠拟合和过拟合。 ​ 高阶多项式回归模型就可能过度拟合训练数据，而线性模型则是拟合不足。 学习曲线​ 另外一种方法是观察学习曲线：这个曲线绘制的是模型在训练集和验证集上，关于”训练集大小“的性能函数。要生成这个曲线，只要在不同大小的训练子集上多次训练模型即可。随着训练样本的逐渐增多，算法训练出的模型的表现能力的变化。 ​ 偏差方差权衡 模型误差=偏差+方差+不可避免的误差 ​ 偏差——原因在于错误的假设。比如假设数据是线性的，而实际上是二次的。高偏差模型最有可能对训练数据拟合不足。 ​ 方差——原因在于模型对于训练数据的微小变化过度敏感。具有高自由度的模型很可能有高方差，所以很容易对训练数据过拟合。 ​ 不可避免的误差——因为数据本身的噪声。清理数据，减少这部分误差。 正则线性模型​ 减少过拟合的一个好办法就是对模型正则化：它拥有的自由度越低，就越不容易过度拟合数据。 ​前面根据线性回归模型的参数估计公式：$\theta=(X^TX)^{-1}X^Ty$可知，得到$\theta$的前提是矩阵$X^TX$可逆。但在实际应用中，可能会出现自变量个数多于样本量（即，矩阵不是n*n的，而是n*m的）或自变量存在多重共线性（比如列方向上存在某一列是另外一列的倍数）的情况，此时无法根据公式计算回归系数的估计值$\theta$。为解决这类问题，基于线性回归模型的另外两种扩展的回归模型，分别是岭回归和LASSO回归。 岭回归​ 岭回归是线性回归的正则化版：在成本函数中添加一个等于$a\sum_{i=1}^{n}\theta_i^2$的正则项。 ​ 【注意】：正则项只能在训练的时候添加到成本函数中，一旦训练完成，你需要使用未正则化的性能指标来评估模型性能。 ​ 训练阶段使用的成本函数与测试时使用的成本函数不同是非常常见的现象。除了正则化以外，还有一个导致这种不同的原因是，训练时的成本函数通常都可以使用优化过的衍生函数，而测试用的性能指标需要尽可能接近最终目标。 也就是， $$ J(\theta)=\sum_{i=1}^n (y-X_b\theta)^2+\alpha \frac{1}{2}\sum_{i=1}^n\theta^2 $$ 为求解目标函数$J(\theta)$的最小值，需要对其求导，并令导函数为0。这里不再推导，只说一下大致步骤： 1）根据线性代数知识，展开目标函数中的平方项； 2）对展开的目标函数求导； 3）令导数为0，计算回归系数$\theta$。 求得结果： $$ \theta=(X_b^TX_b+\alpha \frac{1}{2}E)^{-1}X_b^Ty $$ 这里可以看出来，和之前没有正则项的回归系数相比，仅仅多了正则项的系数。 $\alpha$是L2正则项平方的系数，用来平衡模型的方差（回归系数的方差）和偏差（真实值和预测值之间的差异）。 对于岭回归来说，随着$\alpha$的增大，模型方差会减小而偏差会增大。 >在执行岭回归之前，必须对数据进行缩放，因为它对输入特征的大小非常敏感。 ##### LASSO回归 ​ 与岭回归一样，它也是向成本函数添加一个正则项，但是它增加的是权重向量的L1范数，而不是L2范数的平方的一半。 ​ LASSO回归的一个重要特点是它倾向于完全消除掉最不重要特征的权重（也就是将它们设置为0）。换句话说，LASSO回归会自动执行特征选择并输出一个稀疏模型（即只有很少的特征有非零权重）。 弹性网络​ 弹性网络是岭回归与LASSO回归之间的中间地带。其正则项就是岭回归和LASSO回归的正则项的混合，混合比例通过r来控制。 L1正则，L2正则 梯度下降法定义​ 前面我们求解目标函数都是通过”闭式“方程解，第二种方法是使用优化迭代的方法，即梯度下降。 ​ 梯度下降是一种通用的优化算法，其核心思想就是迭代调整参数，从而使成本函数最小化。 ​ 梯度就是分别对每个变量进行微分，然后用逗号分隔开，梯度是用&lt;&gt;包括起来的，说明梯度其实是一个向量。 J(\Theta)=0.55-(5\theta_1+2\theta_2+12\theta_3) \nabla J(\Theta)= =​ 梯度的意义： 在单变量的函数中，梯度其实就是函数的微分，代表函数在某个给定点的切线的斜率； 在多变量函数中，梯度就是一个向量，向量有方向，梯度的方向就指出了函数在给定点的上升最快的方向。 ​ 梯度下降法，是一种基于搜索的最优化方法；（不是一个机器学习算法） ​ 作用：最小化一个损失函数； ​ 梯度上升法：最大化一个效用函数。 ​ 导数可以代表方向，对应J增大的方向。 -\eta \frac{dJ}{d\theta} ​ 并不是所有函数都有唯一的极值点； ​ **解决方案**： - 多次运行，随机化初始点； - 梯度下降法的初始点也是一个超参数。 ##### 模拟实现梯度下降法 12345678910111213141516171819202122def gradient_descent(initial_theta,eta,epsilon=1e-8): theta=initial_theta theta_history.append(initial_theta) while True: gradient=dJ(theta) last_theta=theta theta=theta-eta*gradient theta_history.append(theta) if(abs(J(theta)-J(last_theta))&lt;epsilon): break def plot_theta_history(): plt.plot(plot_x,J(plot_x)) plt.plot(np.array(theta_history),J(np.array(theta_history)),'ro-') eta=0.9theta_history=[]gradient_descent(0.,eta)plot_theta_history() 线性回归中使用梯度下降法​ 应用梯度下降法，需要保证所有特征值的大小比例都差不多，否则收敛时间会长很多。 ​ 在线性回归中，我们需要求解目标函数最小，现在使用梯度下降法试试： ​ 求解梯度： ​ 实现梯度下降法： 12345678910111213141516171819202122232425262728293031323334353637383940414243def fit_gd(self,X_train,y_train,eta=0.01,n_iters=1e4): """根据训练数据集X_train,y_train,使用梯度下降法训练Linear Regression模型""" assert X_train.shape[0]==y_train.shape[0],\ "the size of X_train must be euqal to the size of y_train" def J(theta,X_b,y):#目标函数 try: return np.sum((y - X_b.dot(theta)) ** 2) / len(X_b) except: return float('inf') def dJ(theta, X_b, y):#求解偏导数 res = np.empty(len(theta)) res[0] = np.sum(X_b.dot(theta) - y) for i in range(1, len(theta)): res[i] = (X_b.dot(theta) - y).dot(X_b[:, i]) return res * 2 / len(X_b) def gradient_descent(X_b, y, initial_theta, eta, n_iters=1e4, epsilon=1e-8): theta = initial_theta i_iter = 0 while i_iter &lt; n_iters: gradient = dJ(theta, X_b, y) last_theta = theta theta = theta - eta * gradient if (abs(J(theta, X_b, y) - J(last_theta, X_b, y)) &lt; epsilon): break i_iter += 1 return theta X_b = np.hstack([np.ones((len(X_train), 1)), X_train]) initial_theta = np.zeros(X_b.shape[1]) # theta向量的行数=X_b向量的列数 self._theta=gradient_descent(X_b,y_train,initial_theta,eta,n_iters) self.interception_=self._theta[0] self.coef_=self._theta[1:] return self ​ 之前我们在目标函数中使用向量化对求解过程进行优化，这里我们也可以使用向量化。 ​ 通过向量化的方式，我们程序在求解计算时就会快很多。 随机梯度下降法​ 批量梯度下降法（Batch Gradient Descent） ​ 这是之前的向量化公式，我们在求解梯度时，每一项都要对所有的样本进行计算。每一步都使用整批训练数据。因此面对非常庞大的训练集时，算法变得极慢。但是梯度下降法随特征数量扩展的表现比较好：如果要训练的线性模型拥有几十万个特征，使用梯度下降法比标准方程快得多。 ​ 随机梯度下降法的学习率不能是一个固定值，需要是递减的。随机性的好处在于可以逃离局部最优，但缺点是永远定位不出最小值。要解决这个困境，有一个办法是逐步降低学习率。【模拟退火的思想】 ​ ​ **SGD算法实现**： 1234567891011121314151617181920212223242526272829303132333435def fit_sgd(self,X_train,y_train,n_iters=5,t0=5,t1=50): """根据训练数据集X_train,y_train,使用随机梯度下降法训练Linear Regression模型""" assert X_train.shape[0]==y_train.shape[0],\ "the size of X_train must be euqal to the size of y_train" assert n_iters&gt;=1 def dJ_sgd(theta, X_b_i, y_i): return X_b_i*(X_b_i.dot(theta)-y_i)*2. def sgd(X_b, y, initial_theta, n_iters, t0=5,t1=50): def learning_rate(t): return t0/(t+t1) theta=initial_theta m=len(X_b) for cur_iter in range(n_iters): indexes=np.random.permutation(m) X_b_new=X_b[indexes] y_new=y[indexes] for i in range(m): gradient = dJ_sgd(theta, X_b_new[i], y_new[i]) theta = theta - learning_rate(cur_iter*m+i) * gradient return theta X_b = np.hstack([np.ones((len(X_train), 1)), X_train]) initial_theta = np.zeros(X_b.shape[1]) # theta向量的行数=X_b向量的列数 self._theta=sgd(X_b,y_train,initial_theta,n_iters,t0,t1) self.interception_=self._theta[0] self.coef_=self._theta[1:] return self ##### 关于梯度的调试 衡量线性回归的指标 ​ **最好的衡量线性回归法的指标**： ​ R Squared： R^2^&lt;=1; R^2^越大越好。当我们的预测模型不犯任何错误时，R^2^得到最大值1； 当我们的模型等于基准模型时，R^2^为0； 如果R^2^&lt;0，说明我们学习到的模型还不如基准模型。此时，很有可能我们的数据不存在任何线性关系。 线性回归算法总结​ 1、评价线性回归算法：R Squared ​ 2、典型的参数学习，对比KNN：非参数学习 ​ 3、只能解决回归问题，对比KNN：既可以解决分类问题，又可以解决线性问题 ​ 4、对数据有假设：线性，对比KNN对数据没有假设 ​ 5、优点：对数据具有强解释性]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>机器学习</tag>
        <tag>梯度下降法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT(v7.0+) 搭建博客：性能优化]]></title>
    <url>%2F2019%2F05%2F20%2Fhexo-performance-optimization%2F</url>
    <content type="text"><![CDATA[在访问很多博客的时候，页面加载和响应速度往往都要上十秒，严重影响用户的体验。本文将探究如何利用常用的方案来进行性能优化，主要包括: CDN加速 Nginx压缩、缓存 图床 首先，可利用 Google PageSpeed Insights 帮助分析网页加载速度，根据报告结果和优化建议进行针对性的优化。常见的网站提速方案有：cdn加速，压缩源文件，nginx gzip压缩，减少网站一些不必要的引入，图片大小等。 CDN加速在阅读下文之前，如果你还不知道 CDN 是什么，请先移步百度百科：CDN词条 进行一些了解。在所有静态资源中，对加载速度影响较大且存在大幅优化空间的主要还是「JavaScript 第三方库」脚本，设定成合适的 CDN 地址，此特性可以加速静态资源的加载。对于我 Hexo 博客来说，NexT 主题已经做好了配置，只需添加 CDN 加载源，将其改为从公共 CDN 加载即可。在 主题配置文件 _config.yml 中修改vendors： themes/next/_config.yml123456# Example:# jquery: //cdn.jsdelivr.net/npm/jquery@2/dist/jquery.min.js# jquery: //cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.jsjquery: //cdn.jsdelivr.net/npm/jquery@2.1.3/dist/jquery.min.js... 比较常用的开源项目 CDN 服务商主要有 unpkg、bootcdn、 cdnjs、jsdelivr 和 cloudflare，本站主要使用 jsdelivr 提供的 CDN 加速服务。 Nginx压缩、缓存 Nginx 是一个高性能的 Web 服务器，可以适当地分配流量（负载均衡器）、流媒体、动态调整图像大小、缓存内容等等，合理配置可以有效提高网站的响应速度。 开启gzipgzip压缩页面需要浏览器和服务器双方都支持，实际上就是服务器端压缩，传到浏览器后浏览器解压并解析。修改nginx.conf，在http模块中增加gzip配置： 1234567891011121314151617181920212223#开启gzip压缩;gzip on;#设置允许压缩的页面最小字节数;gzip_min_length 1k;#设置压缩缓冲区大小，此处设置为4个16K内存作为压缩结果流缓存gzip_buffers 4 16k;#压缩版本gzip_http_version 1.1;#设置压缩比率，最小为1，处理速度快，传输速度慢；9为最大压缩比，处理速度慢，传输速度快;级别越高，压缩就越小gzip_comp_level 6;#制定压缩的类型gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/javascript application/json image/svg+xml application/x-font-ttf font/opentype image/x-icon;#配置禁用gzip条件，支持正则。此处表示ie6及以下不启用gzip（因为ie低版本不支持）gzip_disable "MSIE [1-6]\.";#选择支持vary header；改选项可以让前端的缓存服务器缓存经过gzip压缩的页面; 这个可以不写gzip_vary on; 开启缓存修改nginx.conf，在server中配置缓存和失效时间： 12345678910111213location ~* ^.+\.(ico|gif|jpg|jpeg|png)$ &#123; access_log off; expires 30d;&#125;location ~* ^.+\.(css|js|txt|xml|swf|wav)$ &#123; access_log off; expires 24h;&#125;location ~* ^.+\.(html|htm)$ &#123; expires 1h;&#125; 图床 目前各大云服务商都提供了对象存储服务，如七牛云 QINIU、又拍云 USS、腾讯云 COS、阿里云 OSS 等。我们可以使用这些服务器来存储图片信息，并将其称为图床。 使用图床的好处： 可以减轻服务器的存储压力； 减轻应为图片带来的额外的流量消耗； 图床一般都是具有cdn加速的，可以让你的网页变得更快。 我主要是看中了cdn加速这点，这个对网站的性能提升太重要了。 常用的云存储服务费用对比： 限定符 免费存储空间 免费下载流量 免费请求 免费时间 HTTPS CDN 微博图床 无限 无限 无限 永久 七牛云 10G 10G PUT: 10万次 GET: 100万次 永久 青云QingStor 30G 11G PUT: 10万次 GET: 100万次 12个月 又拍云USS 10G 15G 无限 12个月 阿里云OSS 无 无 无 无 腾讯云COS 50G 无 无 6个月 Github 100G 无限 无限 永久 七牛云是专业云服务商，提供比较完备的服务，且免费额度足够个人博客使用。 七牛云的定位就是 CDN，让你在浏览网页的时候最快的接收到页面中的图片、音频等文件，所以非常适合个人、企业用户用来储存站点资源，且CDN加速也不会产生太多的费用。 微博图床是匿名图床，如果有一天禁止外链访问的话，图片将全部丢失。想着辛辛苦苦制作的图片有丢失的风险，马上就放弃了。【2019年4月微博图床开启了防盗链，对图片 CDN 添加了引用来源Referer检测，对于非微博站内引用的请求统统拒绝访问】 GitHub 看起来是个不错的选择，但是网络访问速度不是很理想，随即放弃了。 阿里云OSS也是个不错的选择，有个9元包年40G存储空间，无限流量。 七牛云综合比较之后：我选择了七牛云的对象存储作为图床(高效、快速、有保障)。 注册账号并实名认证注册 七牛开发者平台 账号，并前往 个人中心 -&gt; 个人信息 实名认证。 新建存储空间 进入控制台，打开 对象存储 -&gt; 新建存储空间， 即可创建新的Bucket。【存储区域】：建议选择一个离你较近的CDN【访问控制】：这里必须选择“公开空间”，因为设置为私有空间，图片的外链是无法访问的。 进入新创建的存储空间，在 空间概览里点击 自定义域名 为空间绑定融合cdn加速域名。详细的参数解释可以参考 官方域名接入文档 。【域名类型】：如果没有特殊需求，选择普通域名即可。【加速域名】：建议填写的是，您未在使用的二级或三级域名等，请勿轻易绑定www域名避免影响您的源站服务。【源站配置】：当您为存储空间绑定自定义域名的时候，源站配置默认为七牛云存储空间即可。 配置CNAME创建加速域名成功后，七牛云会提供CNAME地址，需要在域名服务提供商处将加速域名指向分配的CNAME地址，配置生效后，即可享受CDN加速服务。根据控制台的引导文档并参考 官方配置域名CNAME文档 。 上传文件进入新创建的存储空间，在 内容管理 中上传、下载、访问、修改资源，这样就可以使用资源的外链了。上传图片文件以后，复制外链连接就可以利用这个链接访问这个图片了。 上传工具如果每次都需要在web端点击上传图片，然后复制外链的操作就比较麻烦了，使用工具可以让我们更加方便地上传资源。Mac平台上有多款图床工具，找到了几个优秀的工具，做了个对比： table th:nth-of-type(2){ width: 10%;; } table th:nth-of-type(5){ width: 15%; } 名称 收费标准 优点 缺点 推荐指数 下载链接 ipic 60元/年 剪贴板、压缩、拖拽上传，功能强大，支持多种云服务 免费版只支持微博图床 Mac App Store PicGo 免费 链接上传，支持相册管理 不支持清除上传历史 PicGo.dmg PicUploader 免费 压缩上传，多文件、文件夹同时上传 不支持顶部菜单 PicUploader.zip 云存储管理 免费 链接上传，可视化相册管理 上传速度太慢，会卡死（不能忍受(°⌓°;） 云存储管理客户端 cuImage 免费 剪贴板、压缩、拖拽上传，与ipic类似 仅支持七牛云不支持链接上传 Mac App Store 如果是使用七牛云图床我推荐cuImage，它的功能完善，使用剪贴板、拖曳、甚至是快捷键都可以直接将图片上传到云存储，并直接生成Markdown外链，操作十分简便。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>七牛云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT(v7.0+) 搭建博客：功能强化]]></title>
    <url>%2F2019%2F05%2F19%2Fhexo-function-optimization%2F</url>
    <content type="text"><![CDATA[开源的力量让第三方插件的支持越来越多，本文介绍了在如何利用插件来加强网站的功能，主要包括: 分类时间线 DaoVoice 站内搜索 文章推荐 Valine评论 图片灯箱 分类时间线归档页面的时间线会让文章显示得很有条理，但是分类里却没有，可以通过修改布局自己实现这个时间线功能。 在主题的分类布局文件中添加以下代码： themes/next/layout/category.swig123456789101112131415161718192021222324252627 &#123;% for post in page.posts %&#125;+ &#123;# Show year #&#125;+ &#123;% set year %&#125;+ &#123;% set post.year = date(post.date, 'YYYY') %&#125;+ &#123;% if post.year !== year %&#125;+ &#123;% set year = post.year %&#125;+ &lt;div class="collection-title"&gt;+ &lt;h2 class="archive-year motion-element" id="archive-year-&#123;&#123; year &#125;&#125;"&gt;&#123;&#123; year &#125;&#125;&lt;/h2&gt;+ &lt;/div&gt;+ &#123;% endif %&#125;+ &#123;# endshow #&#125; &#123;&#123; post_template.render(post) &#125;&#125; &#123;% endfor %&#125; …… &#123;% block sidebar %&#125; &#123;&#123; sidebar_template.render(false) &#125;&#125;&#123;% endblock %&#125;+&#123;% block script_extra %&#125;+ &#123;% if theme.use_motion %&#125;+ &lt;script type="text/javascript" id="motion.page.archive"&gt;+ $('.archive-year').velocity('transition.slideLeftIn');+ &lt;/script&gt;+ &#123;% endif %&#125;+&#123;% endblock %&#125; 在线联系DaoVoice该功能由 DaoVoice 插件提供，效果如图： 首先去 DaoVoice官网 注册，输入邀请码 3d64b7fd，注册后查看app_id 并复制，在 主题配置文件 _config.yml 中添加daovoice的配置： themes\next\_config.yml123# Online contactdaovoice: truedaovoice_app_id: &#123;your app_id&#125; 按照官网开发文档说明里 应用设置—&gt;安装到网站的设置，在head的布局模板中插入相关 JavaScript 代码： themes/next/layout/_partials/head.swig123456789101112+&#123;% if theme.daovoice %&#125;+ &lt;script&gt;+ (function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/$&#123;your_app_id&#125;.js","daovoice")+ daovoice('init', &#123;+ app_id: "&#123;&#123;theme.daovoice_app_id&#125;&#125;"+ &#125;);+ daovoice('update');+ &lt;/script&gt;+&#123;% endif %&#125;&#123;# Export some HEXO Configurations to Front-End #&#125;&lt;script id="hexo.configurations"&gt; 具体样式设计可以在 应用设置 -&gt; 聊天设置 后边改。 站内搜索该功能由 hexo-generator-searchdb 提供，效果如图： 在根目录下执行以下命令安装相关依赖： 1$ npm install hexo-generator-searchdb --save 在 主题配置文件 _config.yml 中修改配置local_search： themes\next\_config.yml12345local_search: enable: true # 开启站内搜索 trigger: auto # 自动和手动触发 top_n_per_article: 3 # 每篇文章显示的搜索结果数量 unescape: false 搜索弹框的页边距有点点挤，在自定义样式文件中添加样式规则来增加页边距： themes\next\source\css\_custom\custom.styl12345//增加搜索弹窗的页边距.local-search-popup #local-search-result &#123; padding: 25px 40px height: calc(100% - 95px)&#125; 文章推荐该功能由 hexo-related-popular-posts 插件提供，效果如图： 在站点根目录中执行以下命令安装依赖： 1$ npm install hexo-related-popular-posts --save 在 主题配置文件 _config.yml 中开启相关文章推荐功能： themes/next/_config.yml123456related_posts: enable: true title: # custom header, leave empty to use the default one display_in_home: false params: maxCount: 3 此时会在每篇文章结尾根据标签相关性和内容相关性来推荐相关文章。 事实上并非每篇文章都需要开启该功能，可在文章 Front-Matter 中设置 related_posts 字段来控制是否在文末显示相关文章，然后修改文章布局模板中相关的判定条件： themes/next/layout/_macro/post.swig1234- &#123;% if theme.related_posts.enable and (theme.related_posts.display_in_home or not is_index) %&#125;+ &#123;% if theme.related_posts.enable and (theme.related_posts.display_in_home or not is_index) and post.related_posts %&#125; &#123;% include 'post-related.swig' with &#123; post: post &#125; %&#125; &#123;% endif %&#125; 为了方便可在草稿模板 scaffolds\draft.md 中统一添加 related_posts 字段默认值： scaffolds/draft.md1234 title: &#123;&#123; title &#125;&#125; tags: categories:+ related_posts: true Valine评论 Valine 诞生于 2017 年 8 月 7 日，是一款基于 LeanCloud 提供后端数据服务的快速、简洁且高效的无后端评论系统，支持匿名评论、持Markdown、Emoji等都是它的绝对优势，而且 Next 主题也已经内置了 Valine 组件，使用起来非常方便。 首先，在LeanCloud上注册账号并创建应用，设置LeanCloud的信息。 在 存储 -&gt; 数据 中 新建一个名为Counter 的 Class，ACL权限设置为 无限制：在 设置 -&gt; 安全中心 中添加博客域名到 Web 安全域名中，以保护LeanCloud应用的数据安全。 在LeanCloud中的Class可以理解为数据库中的数据表。Counter用于存储记录文章访问量，记录是以url作为唯一依据的，所以根据默认的permalink组成结构，如果你更改了文章的发布日期和标题中的任意一个，都会造成文章阅读数值的清零重计。 然后，在 主题配置文件 _config.yml 开启评论功能即可： themes/next/_config.yml123456789101112131415valine: enable: true # 开启 Valine 评论 # 设置应用 id 和 key appid: # your leancloud application appid appkey: # your leancloud application appkey # 关闭提醒与验证 notify: false verify: false placeholder: # 文本框默认文字 avatar: mm # gravatar style guest_info: nick,mail # 需要填写的信息字段 pageSize: 10 # 每页评论数 language: zh-cn # language, available values: en, zh-cn visitor: true # 开启文章阅读次数统计 comment_count: false # 首页是否开启评论数 有时候我们并不想在文章标题下显示评论数量，如要隐藏，可在自定义样式文件中添加如下代码： themes/next/source/css/_custom/custom.styl1234//屏蔽标题下的评论数量.post-comments-count &#123; display: none;&#125; 评论区会显示评论人的浏览器和操作系统版本号等信息，如果只想要一个干净的评论界面，而没有多余其他的信息，可在自定义样式文件中添加如下代码： themes/next/source/css/_custom/custom.styl1234//屏蔽评论组件的多余信息#comments .info, #comments .vsys &#123; display: none;&#125; 最后，集成评论服务后，所有的页面也会带有评论，包括标签、关于等页面。这里需要在添加字段comments并将值设置为 false 即可。 12345---title: 标签type: "tags"comments: false--- 图片灯箱添加灯箱功能，实现点击图片后放大聚焦图片，并支持幻灯片播放、全屏播放、缩略图、快速分享到社交媒体等，该功能由 fancyBox 提供。 在根目录下执行以下命令安装相关依赖： 1$ git clone https://github.com/theme-next/theme-next-fancybox3 themes/next/source/lib/fancybox 在 主题配置文件 _config.yml 中设置 fancybox: true： themes\next\_config.yml1fancybox: true 刷新浏览器即可生效。 结束语文章中大量的优化方案都参照了 yearito 的优化精髓，在集成第三方插件或者自定义新功能的过程中尽量做到： 可以在站点配置 / 主题配置文件中方便快捷的开启 / 关闭插件服务 可以在语言包 zh-CN.yml 中快速修改页面中的自定义文案，而不是在代码中将文字表述写死 尽量在自定义样式文件 custom.styl 和自定义布局文件 custom.swig 中添加代码，而非修改主题源码新增文件统一放在 _custom 目录下 所有以上这些原则，尽管实现起来可能更复杂，需要更多的代码，但都是为了让站点更好维护，更灵活方便。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT(v7.0+) 搭建博客：内容优化]]></title>
    <url>%2F2019%2F05%2F18%2Fhexo-content-optimization%2F</url>
    <content type="text"><![CDATA[NexT主题内提供了很多功能来让内容更加丰富，本文介绍了如何开启和定制这些功能，主要包括: 模板设置 文章发布修改时间、字数统计 文章版权声明 链接样式、底部标签样式 图片尺寸处理 代码块复制、显示和隐藏 草稿和发布 模板设置为了便于创建新文章时更加便利，可以在hexo的scaffolds文件夹内创建模板文件，比如我创建的草稿模板 scaffolds/draft.md123456---title: &#123;&#123; title &#125;&#125;categories: tags: date: &#123;&#123; date &#125;&#125;--- 文章发布修改时间在 主题配置文件 _config.yml 中修改post_meta，可用于控制信息的显示： themes/next/_config.yml1234567post_meta: item_text: true # 显示文字说明 created_at: true # 显示文章创建时间 updated_at: enable: false # 文章修改时间 another_day: false # 只有当修改时间和创建时间不是同一天的时候才显示 categories: true # 分类信息 文章字数统计该功能由 hexo-symbols-count-time 提供，效果如图： 在根目录下执行如下命令安装相关依赖： 1$ npm install hexo-symbols-count-time --save 在 站点配置文件 _config.yml 中添加symbols_count_time配置，这些配置项主要用于控制每项统计信息是否显示： _config.yml12345symbols_count_time: symbols: true # 统计单篇文章字数 time: true # 估算单篇文章阅读时间 total_symbols: false # 统计站点总字数 total_time: false # 估算站点总阅读时间 在 主题配置文件 _config.yml 中做如下修改，这些配置项主要用于控制统计信息的显示样式： themes/next/_config.yml123456symbols_count_time: separated_meta: true # 是否换行显示 统计信息 item_text_post: true # 文章统计信息中是否显示“本文字数/阅读时长”等描述文字 item_text_total: false # 站点统计信息中是否显示“本文字数/阅读时长”等描述文字 awl: 4 # Average Word Length：平均字符长度 wpm: 275 # Words Per Minute：阅读速度 文末版权声明NexT主题已经内置了版权声明功能，只需开启配置即可，效果如下： 在 主题配置文件 _config.yml 中开启文章底部的版权声明，版权声明默认使用 CC BY-NC-SA 4.0 许可协议，用户可以根据自身需要修改 licence 字段变更协议： themes/next/_config.yml12345creative_commons: license: by-nc-sa # 开启版权声明 sidebar: true # 侧边栏 post: true # post文章 language: zh-CN 默认版权声明中只有 本文作者、本文链接、版权声明 三项，如果你想添加更多内容，如 文章标题 等，需要先在语言配置文件里补全版权信息文案字段： themes/next/languages/zh-CN.yml123456copyright:+ title : 本文标题 author: 文章作者 link: 原始链接 license_title: 许可协议 license_content: "本文章采用 %s 许可协议，转载请保留原文链接及作者。" 再修改版权声明布局的相关代码： themes/next/layout/_partials/post/post-copyright.swig12345678&lt;ul class="post-copyright"&gt; &lt;li class="post-copyright-title"&gt; &lt;strong&gt;&#123;&#123; __('post.copyright.title') + __('symbol.colon') &#125;&#125;&lt;/strong&gt;&#123;# #&#125;&#123;&#123; post.title | default(config.title) &#125;&#125;&#123;# #&#125;&lt;/li&gt; &lt;li class="post-copyright-author"&gt; &lt;strong&gt;&#123;&#123; __('post.copyright.author') + __('symbol.colon') &#125;&#125; &lt;/strong&gt;&#123;# #&#125;&#123;&#123; post.author || author &#125;&#125;&#123;# 在版权样式文件中添加如下样式： themes\next\source\css\_common\components\post\post-copyright.styl1234567891011121314151617181920212223242526.swal-overlay &#123; background-color: transparent;&#125;.copy-success-message &#123; box-shadow: 0px 4px 12px rgba(0,0,0,0.15); border-radius: 4px; width: auto; margin: 16x 0px; vertical-align: top;&#125;.copy-success-message .swal-content &#123; margin: 0px 0px !important; padding: 10px 16px; line-height: 1em;&#125;.copy-success-message .message-icon &#123; color: #52c41a; margin-right: 8px;&#125;.copy-success-message .message-content &#123; font-size: 14px;&#125; 在实际使用过程中，有些文章是转载别人的文章，文末再出现个人版权声明就不太合适。此时可在Front-Matter中设定变量 copyright 用于控制是否显示版权信息。修改文章布局模板中相关代码，使得只有当主题配置文件中 post_copyright.enable 字段和 page.copyright 字段同时为 true 时才会插入版权声明： themes/next/layout/_macro/post.swig123456- &#123;% if theme.post_copyright.enable and not is_index %&#125;+ &#123;% if theme.post_copyright.enable and page.copyright and not is_index %&#125; &lt;div&gt; &#123;% include 'post-copyright.swig' with &#123; post: post &#125; %&#125; &lt;/div&gt; &#123;% endif %&#125; 为了批量为每篇新文章设定该变量并赋默认值，可以修改草稿模板内容，这样每篇草稿发布为正文后都会默认显示底部版权信息： scaffolds\draft.md1234 title: &#123;&#123; title &#125;&#125; tags: categories:+ copyright: true 链接样式主题自带的链接样式在hover时是灰色的，颜色不明显。在自定义样式文件中添加样式： themes/next/source/css/_custom/custom.styl12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849$link-color = #2780e3;$link-hover-color = #1094e8;$sidebar-link-hover-color = #0593d3; // 普通链接样式a, span.exturl &#123; &amp;:hover &#123; color: $link-hover-color; border-bottom-color: $link-hover-color; &#125; // For spanned external links. cursor: pointer;&#125;// 侧边栏链接样式.sidebar a, .sidebar span.exturl&#123; &amp;:hover &#123; color: $sidebar-link-hover-color; border-bottom-color: $sidebar-link-hover-color; &#125;&#125;// 侧边栏目录链接样式.post-toc ol a &#123; &amp;:hover &#123; color: $sidebar-link-hover-color; border-bottom-color: $sidebar-link-hover-color; &#125;&#125;//文章内链接文本样式.post-body p a&#123; color: $link-color; text-decoration: none; border-bottom: none; &amp;:hover &#123; color: $link-hover-color; text-decoration: underline; border-bottom-color: $link-hover-color; &#125;&#125;// 文章内上下一页链接样式.post-nav-prev a , .post-nav-next a&#123; &amp;:hover &#123; color: $link-hover-color; &#125;&#125; 底部标签添加图标默认情况下标签前缀是 # 字符，可以通过修改主题源码将标签的字符前缀改为图标前缀，效果如图： 在文章布局模板中找到文末标签相关代码段，将 # 换成 &lt;i class=&quot;fa fa-tags&quot;&gt;&lt;/i&gt; 即可： themes/next/layout/_macro/post.swig1234567891011 &lt;footer class="post-footer"&gt; &#123;% if post.tags and post.tags.length and not is_index %&#125; &lt;div class="post-tags"&gt; &#123;% for tag in post.tags %&#125;- &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;# &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;+ &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;&lt;i class="fa fa-tags"&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; &#123;% endfor %&#125; &lt;/div&gt; &#123;% endif %&#125; ... &lt;/footer&gt; NexT中使用 FontAwesome 作为图标库，用户可以在 FontAwesome 上找到心仪的图标来替换标签的字符前缀。 图片尺寸处理 本章节受 bobcn 的方案，自行重构了代码逻辑。 有时候原始图片的尺寸不太合适，想指定图片在文章中的大小，但是 Markdown 原生的图片语法在Hexo中是无效的，这一点让人很困扰（可能是Hexo的Bug，希望以后的版本能够解决这个问题）。现行的处理办法主要有两种方案，一种是使用html标签 1&lt;img width=200 src="/image/test.jpg" &gt; 另一种是 hexo官方文档 推荐的方式 1&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125; 但是习惯了 Markdown 的原生语法之后还是觉得这两种都不够简洁高效，用起来多有不便。于是尝试对 Next 主题进行了加强，变相扩展支持了 Markdown 的插图语法： 可指定像素方法是在 URL 后面添加 ?&lt;width&gt;x&lt;height&gt;，也可以只指定一个参数，图片会等比例缩放。 123![指定像素](/image/test.jpg?200x200)![仅指定width](/image/test.jpg?200x)![仅指定height](/image/test.jpg?x200) 可指定缩放比例方法是在 URL 后面添加 ?&lt;scale&gt;，等比例缩放图片大小至 %。 1![指定比例](/image/test.jpg?40) 如何实现这种效果的呢？首先在自定义脚本目录新建用于处理图片尺寸的 JavaScript 脚本 themes/next/source/js/_custom/hexo_resize_image.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function set_image_size(image, width, height) &#123; image.setAttribute("width", width + "px"); image.setAttribute("height", height + "px");&#125;function hexo_resize_image()&#123; var imgs = document.getElementsByTagName('img'); for (var i = imgs.length - 1; i &gt;= 0; i--) &#123; var img = imgs[i]; var src = img.getAttribute('src').toString(); var fields = src.match(/\?(\d*x\d*)/); if (fields &amp;&amp; fields.length &gt; 1) &#123; var values = fields[1].split("x"); if (values.length == 2) &#123; var width = values[0]; var height = values[1]; if (!(width.length &amp;&amp; height.length)) &#123; var n_width = img.naturalWidth; var n_height = img.naturalHeight; if (width.length &gt; 0) &#123; height = n_height*width/n_width; &#125; if (height.length &gt; 0) &#123; width = n_width*height/n_height; &#125; &#125; set_image_size(img, width, height); &#125; continue; &#125; fields = src.match(/\?(\d*)/); if (fields &amp;&amp; fields.length &gt; 1) &#123; var scale = parseFloat(fields[1].toString()); var width = scale/100.0*img.naturalWidth; var height = scale/100.0*img.naturalHeight; set_image_size(img, width, height); &#125; &#125;&#125;window.onload = hexo_resize_image; 然后在自定义布局文件最后添加 JavaScript 声明 themes/next/layout/css/_custom/custom.swig1&lt;script type="text/javascript" src="/js/custom/hexo_resize_image.js"&gt;&lt;/script&gt; 代码复制NexT主题已经内置了代码复制功能，只需开启配置即可，效果如下： 在 主题配置文件 _config.yml 中开启代码复制功能： themes/next/_config.yml123copy_button: enable: true # 开启代码复制功能 show_result: true # 显示复制结果 搜索的按钮有点移位，在自定义样式文件中调整样式： themes\next\source\css\_custom\custom.styl12345// 复制按钮样式top调整.highlight-wrap .copy-btn &#123; padding: 1px 6px; top: 3px;&#125; 代码块显示和隐藏—- 待完成 —- 草稿和发布一般我们使用` hexo new `来建立文章，这种建立方法会将新文章建立在 **source/_posts** 目录下，当使用 hexo generate 编译文件时，会将其 HTML 结果编译在 public 目录下，之后` hexo server `将会把 public 目录下所有文章发布。 这种建立文章方式是有缺点的！写文章的人都知道，一篇文章从创作到发布需要经过多次润色，若我们的文章还在创作润色中，尚未编辑完成，执行 hexo server 时也会随着一起发布，这样对读者是不友好的。 Hexo 另外提供 draft 机制，它的原理是新文章将建立在 source/_drafts 目录下，因此并不会将其编译到 public 目录下发布，而且提供了很友好的预览功能。 12$ hexo new draft &lt;title&gt; # 新建草稿文章$ hexo s --draft # 预览草稿文章 将草稿发布为正式文章： 1$ hexo P &lt;filename&gt; 其中 &lt;filename&gt; 为不包含 md 后缀的文章名称。它的原理只是将文章从 source/_drafts 移动到 source/_posts 而已。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT(v7.0+) 搭建博客：主题美化]]></title>
    <url>%2F2019%2F05%2F17%2Fhexo-theme-beautifed%2F</url>
    <content type="text"><![CDATA[本文介绍了在 NexT(v7.0+) 主题的基础上整体布局美化的方案，主要包括: Font：字体、动态背景canvas_ribbon Top：进度条、Follow me、菜单背景收缩 Footer：备案显示、运行时间、访客统计 Sidebar：近期文章、浏览进度、左边显示、目录展开 大家可以选择喜欢的方案美化自己的博客，当然最好可以再加入点自己的想法改造。 Font前端的美化，可以做的比较多，比如修改字体、修改背景等等。首先在 主题配置文件 _config.yml 中修改配置font： themes/next/_config.yml12font: enable: true # 开启前端设置 修改字体默认的字体是微软雅黑，有点审美疲劳了 (lll￢ω￢)，在浏览其他人网站的时候看到了一种很有科技感的字体 『Monda』，感觉还是不错的。如何应用到自己的博客呢？首先，可以从 frontyukle 下载字体文件，在服务器上安装。然后在 主题配置文件 _config.yml 中的修改全局字体配置： themes/next/_config.yml123global:- family: Lato+ family: Monda # 设置Monda字体 设置三角丝带背景 该功能由 Vue 作者 尤雨溪 首创。注意：添加动态背景会极大增加页面内存占用及 CPU 消耗。 首先，在根目录下执行以下命令安装相关依赖： 1$ git clone https://github.com/theme-next/theme-next-canvas-ribbon themes/next/source/lib/canvas_ribbon 然后，在 主题配置文件 _config.yml 中的修改配置canvas_ribbon： themes/next/_config.yml123canvas_ribbon: enable: true # 开启随机三角丝带背景 size: 90 # 设置丝带宽度 Top顶部我们保持简洁为主，设置主要包括：进度条、Fork、菜单等等。 加载进度条当网络不好的时候会出现白屏等待，此时如果能有加载进度提示将会提高用户操作体验。首先，在根目录下执行以下命令安装相关依赖： 1$ git clone https://github.com/theme-next/theme-next-pace themes/next/source/lib/pace 然后，修改 主题配置文件 _config.yml 中的配置pace 改为 true，并从上面提供的样式中选择一种填入pace_theme中就可以了。 右上角的Follow-Github如果你想大家在看博客的时候能快速链接到你的Github，不妨设置Github_banner，效果图如下： 修改 主题配置文件 _config.yml 中的配置github_banner，在permalink里配置自己的github地址： themes/next/_config.yml123github_banner: enable: true permalink: https://github.com/yourname 菜单背景收缩在 Muse主题方案中 Header 和 Footer 是没有背景色的，的颜色与内容一致不易区分，而且网站标题的字体不够明显，我做了几个修改 头部和底部颜色修改 网站标题加粗和颜色修改 菜单字体增大显示 在主题自定义样式文件中添加以下样式： themes/next/sources/_custom/custom.styl12345678910111213141516171819202122232425262728293031323334353637383940414243//窗口效果相关样式.sidebar &#123; box-shadow: none;&#125;// 为Header和Footer添加背景色#header, #footer &#123; background-color: rgb(245, 245, 245);&#125;//防止sidebar和footer同时开启动效时堆叠异常#sidebar, header &#123; z-index: 1 !important;&#125;//防止挡住页末文章的阅读全文按钮.main &#123; padding-bottom: 30px;&#125;// 加宽菜单间距，放大菜单图标#menu .menu-item &#123; margin: 0px 14px; .fa &#123; font-size: 16px; &#125;&#125;// Muse主题下自定义样式if hexo-config('scheme') == "Muse" &#123; .site-meta &#123; .brand &#123; color: rgb(34, 34, 34); background: none; &#125; .site-title &#123; font-size: 24px; font-weight: bold; &#125; &#125;&#125; 改完才发现顶部菜单的空间太大了，于是调节菜单高度，在自定义布局文件中添加以下代码： themes/next/layout/_custom/custom.swig1234567&#123;# 页面加载时header高度收缩动效 #&#125;&lt;script&gt; $(document).ready(function () &#123; $(".header-inner").animate(&#123;padding: "25px 0 25px"&#125;, 1000); &#125;);&lt;/script&gt; 如果 custom.swig 文件不存在，需要手动新建并在布局页面中 body 末尾引入： themes/next/layout/_layout.swig1234567 ... &#123;% include '_third-party/copy-code.swig' %&#125; &#123;% include '_third-party/chatra.swig' %&#125; &#123;% include '_third-party/tidio.swig' %&#125;+ &#123;% include '_custom/custom.swig' %&#125;&lt;/body&gt; 调节移动端显示的高度 themes/next/source/css/_schemes/Muse/_menu.styl12345678mobile() &#123; position: absolute; left: 0;- top: 52px;+ top: 95px; margin: 0; ...&#125; Footer底部设置的可完性就比较多了，建站信息、备案信息、以及访客和统计信息等信息都可以个性化定制。 ICP备案和公安备案我们的网站已经有备案号了，但是应该如何添加备案号到博客最下面呢？首先，在 主题配置文件 _config.yml 中的配置添加备案配置： themes/next/_config.yml12345678910 # 这里打开备案信息，填写ICP备案号 beian: enable: true icp: 鄂ICP证18014719号 # 这里是新加的内容，填写公安备案信息+ gongan:+ enable: true+ local: 鄂+ num: 42011102003178 然后，在语言配置文件里，添加表述文案beian： themes/next/languages/zh-CN.yml123footer:+ beian: + gongan: 公网安备%s号 接下来，删除原有的布局文件中备案样式的代码： themes/next/layout/_partials/footer.swig1234567891011 #&#125;&#123;% set current = date(Date.now(), "YYYY") %&#125;&#123;#- #&#125;&#123;% if theme.footer.beian.enable %&#125;&#123;#- #&#125; &#123;&#123; next_url('http://www.beian.miit.gov.cn', theme.footer.beian.icp + ' ') &#125;&#125;&#123;#- #&#125;&#123;% endif %&#125;&#123;# #&#125;&amp;copy; &#123;% if theme.footer.since and theme.footer.since != current %&#125;&#123;&#123; theme.footer.since &#125;&#125; – &#123;% endif %&#125;&#123;# ... &lt;span class="author" itemprop="copyrightHolder"&gt;&#123;&#123; theme.footer.copyright || author &#125;&#125;&lt;/span&gt;+ &lt;span class="post-meta-divider footer-ages-icon"&gt; | &lt;/span&gt; &#123;% if config.symbols_count_time.total_symbols %&#125; 最后，在主题布局文件中添加我们自定义的备案样式： themes/next/layout/_layout.swig1234567891011121314151617 &lt;div class="footer-inner"&gt; &#123;&#123; partial('_partials/footer.swig', &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125; &#123;% include '_third-party/analytics/analytics-with-widget.swig' %&#125;+ &lt;div class="footer-custom"&gt;+ &#123;% if theme.footer.beian.enable %&#125;&#123;#+ #&#125;&#123;&#123; next_url('http://www.beian.miit.gov.cn', theme.footer.beian.icp + ' ') &#125;&#125;&#123;#+ #&#125;&#123;% endif %&#125;+ &#123;% if theme.footer.beian.enable and theme.footer.gongan.enable %&#125;+ &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;+ &#123;% endif %&#125;+ &#123;% if theme.footer.gongan.enable %&#125;&#123;#+ #&#125; &lt;span style="padding-left:25px;background:url(/images/beian.png) no-repeat left center" rel="nofollow"&gt;&#123;#+ #&#125; &#123;&#123; theme.footer.gongan.local&#125;&#125;&#123;&#123;__('footer.beian.gongan', next_url('http://www.beian.gov.cn/portal/registerSystemInfo?recordcode='+theme.footer.gongan.num, theme.footer.gongan.num )) &#125;&#125;&#123;#+ #&#125;&#123;% endif %&#125;+ &lt;/div&gt; &#123;% block footer %&#125;&#123;% endblock %&#125; &lt;/div&gt; 网站的建站时间NexT主题已经内置了添加建站时间。在 主题配置文件 _config.yml 中修改配置since ： themes/next/_config.yml12345678910footer: # Specify the date when the site was setup. If not defined, current year will be used. since: 2018 # 修改建站时间 # Icon between year and copyright info. icon: # `heart` is recommended with animation in red (#ff0000). name: heart # 改成心型图标 # Change the color of icon, using Hex Code. color: "#ff0000" # 改成红色图标 网站的运行时间 本章节受 Yearito’s Blog | 站点运行时间统计 的启发，自行重构了代码逻辑。 接下来我们显示网站的运行时间，在这里我做了一些个性化文案，可供大家参考： 在 主题配置文件 _config.yml 中的添加 ages配置： themes/next/_config.yml1234ages: # site running time enable: true birthday: 20190419 # 网站运行时间 color: "#1094e8" 在语言配置文件里，添加表述文案age： themes/next/languages/zh-CN.yml12footer:+ age: 我已在此等候你 在主题自定义布局文件中添加以下代码： themes/next/layout/_custom/custom.swig12345678910111213141516171819202122232425&#123;# 页脚站点运行时间统计 #&#125; &#123;% if theme.footer.ages.enable %&#125; &lt;script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/moment.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.jsdelivr.net/npm/moment-precise-range-plugin@1.3.0/moment-precise-range.min.js"&gt;&lt;/script&gt; &lt;script&gt; function timer() &#123; var ages = moment.preciseDiff(moment(),moment(&#123;&#123; theme.footer.ages.birthday &#125;&#125;,"YYYYMMDD")); //去除时分秒信息 ages = ages.replace(/\s?\d&#123;0,2&#125;\s+hours?/, ""); ages = ages.replace(/\s?\d&#123;0,2&#125;\s+minutes?/, ""); ages = ages.replace(/\s?\d&#123;0,2&#125;\s+seconds?/, ""); //将年月日转换为中文 ages = ages.replace(/years?/, "年"); ages = ages.replace(/months?/, "月"); ages = ages.replace(/days?/, "天"); ages = ages.replace(/\d+/g, '&lt;span style="color:&#123;&#123; theme.footer.ages.color &#125;&#125;"&gt;$&amp;&lt;/span&gt;'); span.innerHTML = `&#123;&#123; __('footer.age')&#125;&#125; $&#123;ages&#125;`; &#125; var span = document.createElement("span"); //插入到agesicon之后 var agesicon = document.querySelector(".footer-ages-icon"); document.querySelector(".copyright").insertBefore(span, agesicon.nextSibling); timer(); &lt;/script&gt; &#123;% endif %&#125; 添加访客统计该功能由 不蒜子 提供。UV：独立访客数，PV：网站浏览量，访客数和浏览量的区别在于一个用户连续点击n篇文章，会记录n次浏览量，但只记录一次访客数，效果如图： 由于不蒜子是基于域名来进行统计计算的，所以通过 localhost:4000 端口访问的时候统计数据UV和PV都会异常的大，属于正常现象。 首先，在 主题配置文件 _config.yml 中打开不蒜子功能： themes\next\_config.yml12345busuanzi_count: enable: true total_visitors: true # 访客数 total_visitors_icon: user total_views: true # 访问量 然后，在语言配置文件里，修改个性化表述文案： themes/next/languages/zh-CN.yml12345footer:- total_views: 总访问量- total_visitors: 总访客量+ total_views: "历经 %s 次回眸才与你相遇"+ total_visitors: "我的第 %s 位朋友，" 最后，修改不蒜子模板文件： themes/next/layout/_third-party/analytics/busuanzi-counter.swig123456789101112131415161718192021222324252627282930313233&lt;div class="busuanzi-count"&gt; &lt;script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;+ &#123;% if theme.busuanzi_count.enable %&#125;+ &lt;script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;+ &#123;% if theme.busuanzi_count.total_visitors %&#125;- &lt;span class="post-meta-item-icon"&gt;- &lt;i class="fa fa-&#123;&#123; theme.busuanzi_count.total_visitors_icon &#125;&#125;"&gt;&lt;/i&gt;- &lt;/span&gt;- &lt;span class="site-uv" title="&#123;&#123; __('footer.total_visitors') &#125;&#125;"&gt;- &lt;span class="busuanzi-value" id="busuanzi_value_site_uv"&gt;&lt;/span&gt;+ &lt;span class="site-uv"&gt;+ &#123;&#123; __('footer.total_visitors', '&lt;span class="busuanzi-value" id="busuanzi_value_site_uv"&gt;&lt;/span&gt;') &#125;&#125; &lt;/span&gt; &#123;% endif %&#125;- &#123;% if theme.busuanzi_count.total_visitors and theme.busuanzi_count.total_views %&#125;- &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;- &#123;% endif %&#125;- &#123;% if theme.busuanzi_count.total_views %&#125;- &lt;span class="post-meta-item-icon"&gt;- &lt;i class="fa fa-&#123;&#123; theme.busuanzi_count.total_views_icon &#125;&#125;"&gt;&lt;/i&gt;- &lt;/span&gt;- &lt;span class="site-pv" title="&#123;&#123; __('footer.total_views') &#125;&#125;"&gt;- &lt;span class="busuanzi-value" id="busuanzi_value_site_pv"&gt;&lt;/span&gt;+ &lt;span class="site-pv"&gt;+ &#123;&#123; __('footer.total_views', '&lt;span class="busuanzi-value" id="busuanzi_value_site_pv"&gt;&lt;/span&gt;') &#125;&#125; &lt;/span&gt; &#123;% endif %&#125;+ &#123;% endif %&#125;&lt;/div&gt; 在自定义样式文件中添加如下样式： themes/next/source/css/_custom/custom.styl1234//修改不蒜子数据颜色.busuanzi-value &#123; color: #1890ff;&#125; Sidebar侧边栏里的信息有很多，比如站点信息、RSS、链接信息、目录信息等等，我们要有选择性的显示。尽量保持Next主题的宗旨 — 简洁 显示近期文章当你新写了一些好文章，想尽快告诉大家要怎么办呢？放在侧边栏里那是最合适不过了～(￣▽￣～)(～￣▽￣)～ 比如这样： 首先配置开关和文案，便于随时修改。在 主题配置文件 _config.yml 中添加近期文章recent_posts的配置： themes/next/_config.yml123# 近期文章recent_posts: truerecent_posts_layout: block 在语言配置文件里，添加表述文案recent_posts： themes/next/languages/zh-CN.yml12sidebar:+ recent_posts: 近期文章 在侧边栏原有布局文件中的合适位置添加近期文章显示代码： themes/next/layout/_macro/sidebar.swig12345678910111213141516171819202122 &#123;% if theme.social %&#125; ... &#123;% endif %&#125;+ &lt;!-- 添加近期文章 --&gt;+ &#123;% if theme.recent_posts %&#125;+ &lt;div class="links-of-blogroll motion-element &#123;&#123; "links-of-blogroll-" + theme.recent_posts_layout &#125;&#125;"&gt;+ &lt;div class="links-of-blogroll-title"&gt;+ &lt;!-- modify icon to fire by szw --&gt;+ &lt;i class="fa fa-history fa-&#123;&#123; theme.recent_posts_icon | lower &#125;&#125;" aria-hidden="true"&gt;&lt;/i&gt;+ &#123;&#123; __('sidebar.recent_posts') &#125;&#125;+ &lt;/div&gt;+ &lt;ul class="links-of-blogroll-list"&gt;+ &#123;% set posts = site.posts.sort('-date') %&#125;+ &#123;% for post in posts.slice('0', '5') %&#125;+ &lt;li&gt;+ &lt;a href="&#123;&#123; url_for(post.path) &#125;&#125;" title="&#123;&#123; post.title &#125;&#125;" target="_blank"&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt;+ &lt;/li&gt;+ &#123;% endfor %&#125;+ &lt;/ul&gt;+ &lt;/div&gt;+ &#123;% endif %&#125; 显示当前浏览进度在 主题配置文件 _config.yml 中修改back2top的scrollpercent： themes\next\_config.yml1234back2top: enable: true sidebar: false scrollpercent: true # 浏览页面的时候显示当前浏览进度 配置完之后，发现这个按钮颜色有点单调，让它炫酷点的吧 &lt;(￣ˇ￣)/ ，每次刷新可以生成不同的颜色，在自定义样式文件中添加如下样式： themes/next/source/css/_custom/custom.styl1234// 回到顶部样式.back-to-top .fa-arrow-up:before&#123; color: rgb(random-color(0, 255) - 50%, random-color(0, 255) - 50%, random-color(0, 255) - 50%);&#125; 侧边栏移到左边用惯了Ofice的人习惯导航菜单在左边的格式，如何把侧边栏放在左侧呢？NexT 主题中 Pisces 和 Gemini 支持通过主题配置文件来将侧边栏置于左侧或右侧。在 主题配置文件 _config.yml 中修改配置sidebar ： themes/next/_config.yml123sidebar:# Sidebar Position, available values: left | right (only for Pisces | Gemini). position: left # 调整侧边栏显示位置，仅支持 Pisces 和 Gemini 主题 而 Muse 和 Mist 则需要深度修改源码才能实现改变侧边栏位置： themes/next/source/css/_custom/custom.styl1234567.sidebar-toggle &#123; left: 30px;&#125;.sidebar &#123; left: 0px;&#125; 修改动效脚本代码： themes/next/source/js/src/motion.js123456789101112131415161718$(document) .on('sidebar.isShowing', function() &#123; NexT.utils.isDesktop() &amp;&amp; $('body').velocity('stop').velocity(- &#123;paddingRight: SIDEBAR_WIDTH&#125;,+ &#123;paddingLeft: SIDEBAR_WIDTH&#125;, SIDEBAR_DISPLAY_DURATION ); &#125;) ... hideSidebar: function() &#123;- NexT.utils.isDesktop() &amp;&amp; $('body').velocity('stop').velocity(&#123;paddingRight: 0&#125;);+ NexT.utils.isDesktop() &amp;&amp; $('body').velocity('stop').velocity(&#123;paddingLeft: 0&#125;); this.sidebarEl.find('.motion-element').velocity('stop').css('display', 'none'); this.sidebarEl.velocity('stop').velocity(&#123;width: 0&#125;, &#123;display: 'none'&#125;); sidebarToggleLines.init(); ...&#125; 如此以来就可以将侧边栏放置在左边了，但当窗口宽度缩小到991px之后会出现样式错误：侧边栏收缩消失但是页面左侧仍留有空白间距，此时修改如下代码即可： themes/next/source/css/_common/scaffolding/base.styl1234567891011121314body &#123; position: relative; // Required by scrollspy font-family: $font-family-base; font-size: $font-size-base; line-height: $line-height-base; color: $text-color; background: $body-bg-color;- +mobile() &#123; padding-left: 0 !important; &#125;- +tablet() &#123; padding-left: 0 !important; &#125; + +mobile() &#123; padding-right: 0 !important; &#125;+ +tablet() &#123; padding-right: 0 !important; &#125; +desktop-large() &#123; font-size: $font-size-large; &#125;&#125; 侧边栏目录展开侧边栏的TOC目录每次滑到哪儿，目录展开到哪。这样查看文章结构就很不方便，如何设置才能让文章目录默认全部都展开？在 主题配置文件 _config.yml 中修改配置toc ： themes/next/_config.yml123toc: wrap: false ## 如果标题超长，是否换行 expand_all: true ## 侧边栏是否完全展开]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT(v7.0+) 搭建博客：基础安装]]></title>
    <url>%2F2019%2F04%2F29%2Fhexo-satrted%2F</url>
    <content type="text"><![CDATA[关于如何搭建Hexo博客的文章已经有很多人写过了，并且有很多人已经写的很深刻很到位了，为什么还要重复写一遍呢？直到我看到了这位同学的博客 yearito （ ps：本站的建站优化大都参考自这里） ，我有了说服自己的理由： 你可以参考别人的技术方案，集众所长，亲自实践，然后融入自己的思考写出一篇新文章 即使并没有做出创新性的贡献，自己重新归纳一遍也有助于梳理流程，深化理解 现在百度 Google 很方便，动动手指就可以搜索到想要的答案，但是太多人都是『顺手拈来、过目就忘』，下次遇到同样的问题再搜索一遍。为什么会这样呢？不善于总结，不情愿动手思考，时而久之就会变成所谓的 “代码搬运工” ！ 闲话不多说了，我们开始吧！ 安装node.js在 官方下载网站 下载源代码，选择最后一项 Source Code解压到某一目录, 然后进入此目录,依次执行以下 3 条命令 123$ ./configure$ make$ sudo make install 安装完后查看node.js版本，检验是否安装成功 1$ node -v 安装hexo在命令行中通过 npm 来安装 hexo： 1$ npm install -g hexo-cli 本地启动hexo创建一个博客目录（例如 /my-blog），在此目录下，执行初始化命令 123$ mkdir -p my-blog$ cd my-blog$ hexo init 执行完毕后，将会生成以下文件结构： 123456789101112.|-- node_modules //依赖安装目录|-- scaffolds //模板文件夹，新建的文章将会从此目录下的文件中继承格式|-- source //资源文件夹，用于放置图片、数据、文章等资源| |-- _posts //文章目录|-- themes //主题文件夹| |-- landscape //默认主题|-- .gitignore //指定不纳入git版本控制的文件|-- _config.yml //站点配置文件|-- db.json|-- package.json`-- package-lock.json 在根目录下执行如下命令启动hexo内置的web容器 12$ hexo generate # 生成静态文件$ hexo server # 在本地服务器运行 在浏览器输入IP地址 http://localhost:4000 就可以看到我们熟悉的 Hello Word 了。 常用命令简化和组合1234$ hexo g # 等同于hexo generate$ hexo s # 等同于hexo server$ hexo p # 等同于hexo port $ hexo d # 等同于hexo deploy 当本地不想使用默认的4000端口时（比如在服务器上，默认使用80端口），可以使用 port 命令更改启动端口另外，hexo支持命令合并，比方说 生成静态文件 → 本地启动80端口，我们可以执行 1$ hexo s -g -p 80 安装NexT主题hexo 安装主题的方式非常简单, 只需几个简单的命令即可。将NexT主题文件拷贝至themes目录下，然后修改 站点配置文件 _config.yml 中的 theme字段为next即可。 cd 到博客的根目录下执行以下命令下载主题文件： 12345$ cd my-blog$ git clone https://github.com/theme-next/hexo-theme-next.git themes/next$ vim _config.ymltheme: next 清除 hexo缓存，重启服务 12$ hexo clean$ hexo s -g 大部分的设定都能在 NexT官方文档 里找到, 如主题设定、侧栏、头像、友情链接、打赏等等，在此就不多讲了，照着文档走就行了。]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
